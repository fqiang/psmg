/* (c) 2008,2009 Jonathan Hogg and Andreas Grothey, University of Edinburgh
 *
 * This file is part of SML.
 *
 * SML is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, using version 3 of the License.
 *
 * SML is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 */
%debug

%{
    #define YYERROR_VERBOSE
    #include <stdio.h>
    #include <stdlib.h>
    #include <assert.h>
    #include <iostream>
    #include "../model/ObjComp.h"
    #include "../model/ModelComp.h" 
    #include "../model/AmplModel.h"
    #include "../model/SyntaxNode.h"
    #include "../model/SyntaxNodeOP.h"
    #include "../model/SyntaxNodeID.h"
    #include "../model/SyntaxNodeValue.h"
    #include "../model/SyntaxNodeIDREF.h"
    #include "../model/SyntaxNodeIDREFM.h"
//    #include "../st_model/StochModel.h"
//    #include "../st_model/StochModelComp.h"
   
    #include "../sml/GlobalVariables.h"
    #include "../util/global_util_functions.h"
    
    using namespace std;

    void print_index_dummy_vars();
    void record_dummy_var();
    void restore_dummy_var();
 
    void begin_model(const string& name, SyntaxNode *indexing);
    void end_model(const string& name);
    void begin_smodel(const string& name, SyntaxNode *indexing, SyntaxNode *stochsets);
    void end_smodel(const string& name);

    extern int yylineno;
    int yylex(void);
    void yyerror(const char *s);

    static AmplModel *current_model;    /* this is the model currently active */
                                       /* this is the GLOBAL context */

	vector<string> index_dummy_vars;    
	vector<int> dummy_var_size;                                            
	bool isDummyVar(string&);
	                                                
    /* ---------------- stochastic global variables:------------------------ */
    static bool is_stoch_model;      /* true if inside stochastic model def */
    /* these are set by global stocastic modifier commands */
    static bool is_deterministic_glo;
    static SyntaxNode *stages_glo;
    extern FILE *yyin;

    void addStochInfo(ModelComp *newmc, SyntaxNode*);
%}

%union
{
  int optype;
  objType otype;
  long *ival;
  double *fval;
  char* string;
  AmplModel* model;
  SyntaxNode *opPtr;
}

%type <opPtr> expr value  expr_list 
%type <opPtr> stochattr_opt 
%type <opPtr> setattributes_opt setattribute 
%type <opPtr> paramattributes_opt paramattribute
%type <opPtr> varattributes_opt varattributes varattribute
%type <opPtr> lexpr 
%type <opPtr> setexpression identifier
%type <opPtr> indexing_opt indexing_set 
%type <opPtr> indexing_condition_opt indexing_setexpr_list indexing_setexpr_item /*set_identifier */
%type <opPtr> indexing_dummy indexing_dummy_list
%type <optype> relop reduction_op func_op ubsetop bsetop blogic_op ulogic_op b_compare_op
%type <otype> objdef_type

%token <string> ID 
%token <ival> INT_VAL
%token <fval> FLOAT_VAL 
%token INFINITE COEFF COVER OBJ DEFAULT FROM TO TO_COME MODELTYPE DOTDOT
%token NET_IN NET_OUT DIMEN ORDERED CIRCULAR REVERSED SYMBOLIC ARC
%token INTEGER BINARY CHECK CLOSE DISPLAY DROP INCLUDE PRINT PRINTF QUIT RESET
%token RESTORE SOLVE UPDATE WRITE SHELL MODEL DATA OPTION LET SOLUTION FIX
%token UNFIX END FUNCTION PIPE FORMAT SETOF BY LESS MOD DIV MIN MAX IF THEN
%token ELSE AND OR EXISTS FORALL NOT WITHIN WHILE REPEAT FOR CARD NEXT NEXTW
%token PREV PREVW FIRST LAST MEMBER ORD ORD_ZERO VAR PARAM SET MAXIMIZE MINIMIZE
%token OBJECTIVE SUBJECTTO SUM PROD IN POWER NE LE GE EQ LT GT SIN COS UNION DIFF
%token CROSS INTER SYMDIFF LBRACE RBRACE COMMA SEMICOLON LSBRACKET RSBRACKET
%token COLON LBRACKET RBRACKET DEFINED /* LOGICAL_OR LOGICAL_AND  ELLIPSE */
%token SUFFIX BLOCK
%token USING DETERMINISTIC EXPECTATION STOCHASTIC STAGES
%token ANCESTOR
%token IDREF IDREFM VALUE LIST INDEX DVAR DOT STAGE NODE


%nonassoc ASSIGN
%left OR
%left AND
%left EQ NE
%left LT LE GT GE
%left PLUS MINUS
%left TIMES DIVID
%right SUM
%left POWER
%left '!'
%right DEFINED
%left DOTDOT


%%

statements: /* empty */
          | statements statement 
          ;

block:   stochblock
     |   blockblock
     |   stageblock
     ;
         
/* -------------------------------------------------------------------- 
  blockblock
------------------------------------------------------------------------- */
blockblock: BLOCK ID 
			{  
				YAC_MODEL_LOG("blockblock: -- started -- "<<$2);
				record_dummy_var();
			} indexing_opt COLON {   
				begin_model($2,$4);
			} LBRACE statements RBRACE {
               	end_model($2);
               	restore_dummy_var();
            }
          ;
         
/* -------------------------------------------------------------------- 
  stochblock
------------------------------------------------------------------------- */
/* A stochblock is a block definition of the form

     [sblock/stochastic block] name{indexing} using (NODES,ANC,PROB,STAGES):
       statements
     end sblock;

where 
  NODES: set of nodes in the tree
  ANC{NODES}: ancestor for every node
  PROB{NODES}: conditional probability of reaching this node from parent
  STAGES: set of time stages 

  The whole block is repeated over all STAGES (actually over all NODES). 
  Entities marked 'deterministic' are only repeated over STAGES

-------------------------------------------------------------------- */
stochblock: BLOCK ID
			{
				YAC_MODEL_LOG("stochblock: -- started - "<<$2);
				record_dummy_var();
			} indexing_opt STOCHASTIC USING LBRACKET indexing_setexpr_list RBRACKET COLON 
			{
				is_stoch_model = true;
				assert(false); //$8 is already included in the the indexing
				begin_smodel((char*)$2, $4, $8);
    	    } LBRACE statements RBRACE 
    	    {
               end_smodel((char*)$2);
               
               is_stoch_model = false;
	           restore_dummy_var();
               YAC_MODEL_LOG("vardef: -- end -- "<<$2);
            }
          ;

/* -------------------------------------------------------------------- 
  stageblock
------------------------------------------------------------------------- */

stageblock: STAGES
			{
				assert(is_stoch_model == true);
				record_dummy_var();		
			} indexing_set COLON 
			{    
				stages_glo = $3;
	        } LBRACE statements RBRACE {
                stages_glo = NULL;
				restore_dummy_var();            	
            }
          	;

stochattr_opt: /* empty */ {$$ = NULL;}
             |	DETERMINISTIC 
             	{
                	assert(is_stoch_model==true);
                  	$$ = new SyntaxNode(DETERMINISTIC);
             	}
             | 	STAGES
             	{
                	assert(is_stoch_model==true);
             		record_dummy_var();
             	} indexing_set 
             	{
                	restore_dummy_var(); 
                  	$$ = $3;
               	}
             ;

/* -------------------------------------------------------------------- 
  ``Standard'' AMPL
------------------------------------------------------------------------- */

statement:  setdef 
         |  paramdef
	     |  vardef
	     |  consdef
	     | 	objdef
 	     |  block
         ;

/****************************************************************************/
// Indexing 
// not allowing dummy set declaration
// no recursive indexing set declaration.
// indexing_set : { .... , .... , .... : condition }
/**************************************************************************/     

indexing_opt: /* empty */ {		$$=NULL;	}
            | indexing_set { $$ = $1; }
            ;

indexing_set:	LBRACE indexing_setexpr_list indexing_condition_opt RBRACE 
				{	
					YAC_MODEL_LOG("indexing -- rule matched!");
					SyntaxNode *tmp = NULL;
		      		tmp = new SyntaxNode(LBRACE, new SyntaxNode(COLON, $2, $3));
		           	$$ = tmp;
		           	YAC_MODEL_LOG("indexing -- rule end -- "<<$$->print());
				}
			;

indexing_condition_opt: /* empty */ { $$=NULL; }
				  		| COLON lexpr
				  		{
				  			$$=$2;
				  		}
				  		;
		

indexing_setexpr_list:  indexing_setexpr_item {  $$ = new SyntaxNode(COMMA,$1); }
            |  indexing_setexpr_list COMMA indexing_setexpr_item
            {
                  assert($1->opCode == COMMA);
                  $1->push_back($3);
                  $$ = $1;
			}
            ;

indexing_setexpr_item:	identifier
						{  
							$$ = $1; 
						} 
			            | indexing_dummy_list IN identifier 
			         	{
			              	assert($1->opCode == COMMA);
		              		$$ = new SyntaxNode(IN, $1,$3);
			           	}
			           	| INT_VAL
			           	{
			           		$$ = new SyntaxNodeValue(*$1);
			           	}
			           	| expr DOTDOT expr
			           	{
			           		$$ = new SyntaxNode(DOTDOT, $1, $3);
			           	}            

indexing_dummy_list:ID 
					{ 
						SyntaxNodeID* idnode = new SyntaxNodeID($1);
						index_dummy_vars.push_back(idnode->id);
						$$ = new SyntaxNode(COMMA, idnode);
					}
			  		| LBRACKET indexing_dummy RBRACKET 
			  		{ 
			  			$$ = $2;
			  		}
			  		;
		  
indexing_dummy: ID 
				{
					SyntaxNodeID* idnode = new SyntaxNodeID($1);
					index_dummy_vars.push_back(idnode->id);
					$$ = new SyntaxNode(COMMA, idnode);
				}
			   	|indexing_dummy COMMA ID
			   	{
			   		assert($1->opCode == COMMA);
			   		SyntaxNodeID* idnode = new SyntaxNodeID($3);
			   		$1->push_back(idnode);
					index_dummy_vars.push_back(idnode->id);
			   		$$ = $1;
			   	}
			   	;
			   
/****************************************************************************/		
/*  -------------------------------------------------------------------
 set def statement
 -------------------------------------------------------------------   */
setdef:	SET ID
		{
			YAC_MODEL_LOG("setdef: start -- ID=["<<$2<<"]");
			record_dummy_var();
		} indexing_opt stochattr_opt setattributes_opt SEMICOLON
        {
            YAC_MODEL_LOG("indexing_opt=["<<$4<<"]");
            YAC_MODEL_LOG("stochattr_opt=["<<$5<<"]");
            YAC_MODEL_LOG("setattributes_opt=["<<$6<<"]");
            ModelComp *newmc;
            if (is_stoch_model){
            	assert(false); //TODO: stochastic fix
 //              newmc = new StochModelComp($2, TSET, $4, $6);
 //              addStochInfo(newmc, $5);
            }else{
               newmc = new SetComp($2, $4, $6);
            }
            current_model->addComp(newmc);
           	
           	restore_dummy_var();
           	YAC_MODEL_LOG("setdef: -- end -- "<<$2);
        }
      ;
      
setattributes_opt:   /* empty */ { $$=NULL; }
                 |	setattributes_opt setattribute  
                 	{
                 		if($1!=NULL)
                 		{
                 			assert($1->opCode==COMMA);
                 			$1->push_back($2);
                 			$$ = $1;
                 		}
                 		else
                 		{
                 			$$ = new SyntaxNode(COMMA,$2);
                 		}
                 	}
                 ;
                 

setattribute: 	DIMEN INT_VAL 
				{
					$$ = new SyntaxNode(DIMEN, new SyntaxNodeValue(*$2));
	           	}
            | 	ASSIGN
            	{
            		record_dummy_var();
            	} setexpression 
	            {
					$$ = new SyntaxNodeOP(ASSIGN, $3);
	            	restore_dummy_var();
				}
			|	WITHIN identifier
				{
					assert($2->opCode == IDREF);
					$$ = new SyntaxNode(WITHIN, $2);
				}
            | 	ORDERED 
            	{ 
            		$$ = new SyntaxNode(ORDERED); 
            	}
            ;      

/*  -------------------------------------------------------------------
 param def statement
 -------------------------------------------------------------------   */
paramdef:  	PARAM ID
			{
				YAC_MODEL_LOG("paramdef: -- start -- "<<$2);
				record_dummy_var();
			} indexing_opt stochattr_opt paramattributes_opt SEMICOLON {
			   	ModelComp *newmc;
			   	if (is_stoch_model){
			   		YAC_MODEL_LOG("paramdef: -- stochInfo --"<<$5);
			   		assert(false); //TODO: stochastic fix
//			      	StochModelComp *newmcs = new StochModelComp($2,TPARAM,$4,$6);
//			      	addStochInfo(newmcs, $5);
//			      	newmc = newmcs;
			   	}else{
			   		newmc = new ParamComp($2, $4, $6);
			   	}
               	current_model->addComp(newmc);
               	
               	restore_dummy_var();
               	YAC_MODEL_LOG("paramdef: -- end -- "<<$2);
            }
        ;
        
paramattributes_opt: /* empty */ { $$ = NULL; }
                   | paramattributes_opt paramattribute 
                   	 {
                   	 	if($1!=NULL)
                 		{
                 			assert($1->opCode == COMMA);
                 			$1->push_back($2);
                 			$$ = $1;
                 		}
                 		else
                 		{
                 			$$ = new SyntaxNode(COMMA,$2);
                   	 	}
                   	 }
                   	 
                   ;
                   
paramattribute:   BINARY {$$ = new SyntaxNode(BINARY);}
              |   INTEGER {$$ = new SyntaxNode(INTEGER);}
              |   SYMBOLIC {$$ = new SyntaxNode(SYMBOLIC);}
              |   relop expr {$$ = new SyntaxNodeOP($1, $2);}
              |   DEFAULT expr {$$ = new SyntaxNode(DEFAULT, $2);}
              |   DEFINED expr {$$ = new SyntaxNodeOP(DEFINED, $2);}
              ;
              
relop:   LE {$$=LE;}
     |   GE {$$=GE;}
     |   LT {$$=LT;}
     |   GT {$$=GT;}
     |   EQ {$$=EQ;}
     |   NE {$$=NE;}
     ;
     	   
/*  -------------------------------------------------------------------
 var def statement
 -------------------------------------------------------------------   */
vardef: VAR ID 
		{
			YAC_MODEL_LOG("vardef: -- start -- "<<$2);
			record_dummy_var();
		}indexing_opt stochattr_opt varattributes_opt SEMICOLON {
            ModelComp *newmc;
            if (is_stoch_model){
            	assert(false); //TODO: stochastic fix
//               	newmc = new StochModelComp($2, TVAR, $4, $6);
//               	addStochInfo(newmc, $5);
            }else{
               newmc = new VarComp($2, $4, $6);
            }

            current_model->addComp(newmc);
          	restore_dummy_var();
          	YAC_MODEL_LOG("vardef: -- end -- "<<$2);
        }
      ;
     
varattributes_opt:   /* empty */ {$$=NULL;}
                 |   varattributes {$$ = $1;}
                 ;


varattributes: varattribute 
			   {
					$$ = new SyntaxNode(COMMA,$1); 
               }
             | varattributes COMMA varattribute 
               {
               		assert($1->opCode == COMMA);
             		$1->push_back($3);
             		$$ = $1;
               }
             ;

varattribute:  BINARY {$$ = new SyntaxNode(BINARY);}
            |  INTEGER {$$ = new SyntaxNode(INTEGER);}
            |  LE expr {$$ = new SyntaxNodeOP(LE, $2);}
            |  GE expr {$$ = new SyntaxNodeOP(GE, $2);}
            |  DEFAULT expr {$$ = new SyntaxNode(DEFAULT, $2);}
            |  SUFFIX ID expr {$$ = new SyntaxNode(SUFFIX, new SyntaxNodeID($2), $3);}
            ;
     
/*  -------------------------------------------------------------------
 consdef def statement
 -------------------------------------------------------------------   */     
consdef:	SUBJECTTO ID
			{
				YAC_MODEL_LOG("consdef: -- start -- "<<$2);
				record_dummy_var();
			} indexing_opt stochattr_opt COLON expr SEMICOLON
			{
				YAC_MODEL_LOG("consdef: -- indexing -- "<<$4);
				ModelComp *newmc;
	            if (is_stoch_model){
					assert(false); //TODO: stochastic fix
//	               newmc = new StochModelComp($2, $4, $7);
//	               addStochInfo(newmc, $5);
	            }else{
	               newmc = new ConsComp($2, $4, $7);
	            }
	            current_model->addComp(newmc);
	            
	            restore_dummy_var();
	            YAC_MODEL_LOG("consdef: -- end -- "<<$2);
			}
			;

/*-------------------------------------------------------------------------
objdef def statement
--------------------------------------------------------------------------*/
objdef: objdef_type ID stochattr_opt COLON expr SEMICOLON
		{
			YAC_MODEL_LOG("objdef: -- "<<$2);
			ModelComp *newmc;
            if (is_stoch_model){
	            assert(false); //TODO: stochastic fix
//               newmc = new StochModelComp($2, $1, NULL, $5); //as NULL for indexing
//               addStochInfo(newmc, $5);
            }else{
               newmc = new ObjComp($2, $1, $5);
            }
            current_model->addComp(newmc);
            
            YAC_MODEL_LOG("objdef: -- end -- "<<$2);
		}
		;
		
objdef_type:	MAXIMIZE { $$ = TMAX; }  
  			| 	MINIMIZE { $$ = TMIN; }
  			;
  			
/*-------------------------------------------------------------------------*/
			   
/* this is anything that evaluates to a set */
setexpression: 	indexing_set 
				{
					YAC_MODEL_LOG("setexpression: indexing -- "<<$1);
					$$= $1;
				}
			 	| identifier 
			 	{
		     		YAC_MODEL_LOG("setexpression: identifier -- rule matched -- "<<$1);
		     		assert($1->opCode == IDREF);
		     		$$ = $1;
             	}
             	| SETOF 
             	{ 
	         		YAC_MODEL_LOG("setexpression - setof -- start ");
	         		record_dummy_var();
	         	} indexing_set identifier {
	         		restore_dummy_var();
	         		$$ = new SyntaxNode(SETOF,$3,$4);
	            }
             	| setexpression bsetop setexpression {
					$$ = new SyntaxNode($2, $1, $3);
               	}
             	| setexpression ubsetop setexpression {
                  	$$ = new SyntaxNode($2, $1, $3);
               	}
             	;


bsetop:  DIFF     { $$ = DIFF; }
      |  SYMDIFF  { $$ = SYMDIFF; }
      |  CROSS    { $$ = CROSS; }
      ;

ubsetop: UNION    { $$ = UNION; }
      |  INTER    { $$ = INTER; }
      ;
      
/*------------------------------------------------------------------------------------ */

//Logical expression
/*------------------------------------------------------------------------------------ */
lexpr:  identifier IN identifier {
			YAC_MODEL_LOG("lexpr: identifier IN identifier - rule matched! "<<$1<<" "<<$3);
			assert($3->opCode == IDREF);
			$$ = new SyntaxNode(IN,$1,$3);
		}
     |  LBRACKET lexpr RBRACKET {
            $$ = $2; 
		}
     |  lexpr blogic_op lexpr 
     	{
     		$$ = new SyntaxNode($2,$1,$3);
     	}
     |  ulogic_op lexpr
     	{
     		$$ = new SyntaxNode($1,$2);
     	}
     |  expr b_compare_op expr 
     	{
     		$$ = new SyntaxNode($2, $1, $3);
     	}
     ;
     
b_compare_op: NE { $$ = NE; }
			| LE { $$ = LE; }
			| GE { $$ = GE; }
			| LT { $$ = LT; }
			| GT { $$ = GT; }
			| EQ { $$ = EQ; }
			;
			
blogic_op: AND { $$ = AND; }
		| OR  {  $$ = OR; }
		;
ulogic_op: NOT  {  $$ = NOT; }
		;
		
/*------------------------------------------------------------------------------------ */
      

/* Identifier is any quotation of a predefined object:
    RoutComm[j].Flow[k-3*j, k]#
   An iditem is simply a tree of SyntaxNodes that serve as an identifier.
   An 'identifer' is a SyntaxNode of type IDREF or IDREFM.
*/
identifier: ID 
			{
			   	YAC_MODEL_LOG("identifier: ID  -- "<<$1);
			   	string key = $1;
			   	if(isDummyVar(key))
			   	{
					$$ = new SyntaxNodeID($1);
			   	}
			   	else
			   	{
			   		ModelComp* 	ref = current_model->findModelComp(key);
			   		if(ref->type == TMODEL){
			   		   	$$ = new SyntaxNodeIDREFM(IDREFM,new SyntaxNodeID($1),static_cast<AmplModel*>(ref));
				   	}
				   	else
				   	{
				   	   	$$ = new SyntaxNodeIDREF(IDREF,new SyntaxNodeID($1),ref);
				   	}
			   	}
            }
          | ANCESTOR LBRACKET INT_VAL RBRACKET DOT identifier
          	{
          		assert(is_stoch_model==true);
	            $$ = new SyntaxNode(ANCESTOR, new SyntaxNodeValue(*$3), $6);
          	}
          | identifier LSBRACKET expr_list RSBRACKET
          	{
          		$1->push_back($3);
          		$$ = $1;
          	}    
          | identifier DOT
          	{
               	$<model>$ = current_model;
          		assert($1->opCode == IDREFM);
          		current_model = static_cast<SyntaxNodeIDREFM*>($1)->ref;
			}
			identifier
			{
				 $$ = new SyntaxNode(DOT, $1, $4); 
				 current_model = $<model>3;
			}
          ;

/*------------------------------------------------------------------------------------ */

expr_list:	expr 
			{
				YAC_MODEL_LOG("expr_list: expr rule matched! "<<$1);
               	$$ = new SyntaxNode(COMMA,$1);
            }
         |  expr_list COMMA expr 
         	{ 
         		YAC_MODEL_LOG("expr_list: expr_list COMMA expr -- "<<$1);
         		YAC_MODEL_LOG("expr_list: expr_list COMMA expr -- "<<$3);
               	assert($1->opCode == COMMA);
               	$$ = $1->push_back($3);
            }
         ;

expr: value 
	{ 
		YAC_MODEL_LOG("expr: value rule matched!" <<$1);
		$$ = $1;
	}
	| identifier
	{
		$$ = $1;
	}
    | LBRACKET expr RBRACKET { $$ = $2; }
    | MINUS expr { $$ = new SyntaxNodeOP(MINUS, $2); }
    | expr PLUS expr { $$ = new SyntaxNodeOP(PLUS, $1, $3); }
    | expr MINUS expr { $$ = new SyntaxNodeOP(MINUS, $1, $3); }
    | expr TIMES expr { $$ = new SyntaxNodeOP(TIMES, $1, $3); }
    | expr DIVID expr { $$ = new SyntaxNodeOP(DIVID, $1, $3); }
    | expr POWER expr { $$ = new SyntaxNodeOP(POWER, $1, $3); }
    | expr ASSIGN expr { $$ = new SyntaxNodeOP(ASSIGN, $1, $3); }
    | IF lexpr THEN expr { $$ = new SyntaxNode(IF, $2, $4); }
    | IF lexpr THEN expr ELSE expr { $$ = new SyntaxNode(IF, $2, $4, $6); }
    | EXPECTATION LBRACKET expr_list RBRACKET 
      { 
      	$$ = new SyntaxNode(EXPECTATION, $3);
      }
    | func_op LBRACKET expr RBRACKET 
      { 
      	$$ = new SyntaxNode($1, $3);
      }
    | reduction_op
	  {	
	  	record_dummy_var();
	  } indexing_set LBRACKET expr RBRACKET 
      {  
		restore_dummy_var();
      	$$ = new SyntaxNode($1, $3, $5);
      }
    ;

func_op : ORD  { $$=ORD;   }
		| CARD { $$=CARD;  }
		| SIN  { $$ = SIN; }
		| COS  { $$ = COS; }
		;

reduction_op:  SUM { $$=SUM; }
            |  MAX { $$=MAX; }
            |  MIN { $$=MIN; }
            |  PROD { $$=PROD; }
            ;

value:   INT_VAL {
            $$=new SyntaxNodeValue(*$1);
         }
     |   FLOAT_VAL { 
            $$=new SyntaxNodeValue(*$1);
         }
     |   INFINITE { 
            $$ = new SyntaxNode(INFINITE);
         }
     ;

%%

void yyerror(const char *s) {
   cerr << "MODEL: " << s << " on line " << yylineno << "\n";
}


/* ----------------------------------------------------------------------------
yywrap
---------------------------------------------------------------------------- */
/* not sure if this is correct, found this somewhere on the internet
   should open the data file and somehow tell the parser to carry on 
   reading in "data mode"
 */
int yywrap(void) {
   return 1;
}

/* ----------------------------------------------------------------------------
begin_model
---------------------------------------------------------------------------- */
void begin_model(const string& name, SyntaxNode *indexing) 
{
	YAC_MODEL_LOG("begin_model  ["<< name <<"] indexing["<<indexing->print()<<"] -- curr model["<<current_model->name<<"]");
	AmplModel *new_mod = new AmplModel(name,current_model,indexing);
	
	current_model->addComp(new_mod);
	  
	/* and change current model */
	current_model = new_mod;
	YAC_MODEL_LOG("     current model now "<<current_model->name);
}

/* ----------------------------------------------------------------------------
begin_smodel
---------------------------------------------------------------------------- */
void begin_smodel(const string& name, SyntaxNode *indexing, SyntaxNode *stochsets) 
{
	assert(false); // TODO fix stocahstic!
   LOG_SM("Start Stochastic Model: " << name <<"indexing ["<<indexing->print()<<"]");
   if (!stochsets || stochsets->nchild()!=4){
      cerr << "Syntax error in Stochastic Block definition: \n";
      cerr << " 'USING' needs 4 parameters \n";
      exit(1);
   }

   SyntaxNode::iterator i = stochsets->begin();
   SyntaxNode *nodes = *i;
   SyntaxNode *anc = *(++i);
   SyntaxNode *prob = *(++i);
   SyntaxNode *stages = *(++i);
   LOG("   anc = [" << anc << endl << "]   prob = [" << prob<<"]"<< "   stages = [" << stages<<"]");
 //  StochModel* new_mod = new StochModel(name, stages, nodes, anc, prob, current_model);
  
 //  ModelComp* newmc = new ModelComp(name, TMODEL, indexing, NULL);
 //  newmc->other = new_mod;

 //  new_mod->node = newmc;            /* add pointer-to-node to the model */
 //  current_model->addComp(newmc);
 
   /* and change current model */
 //  current_model = new_mod;
}

/* ----------------------------------------------------------------------------
end_model
---------------------------------------------------------------------------- */
void end_model(const string& name) 
{
	YAC_MODEL_LOG("end_model -- ["<<current_model->name<<"]");
	// Check end block name matches block name
	if (string(name) != current_model->name) {
		cerr << "end block '" << name << "' encountered in block '" << 
		current_model->name << "'" << endl;
		exit(1);
	}
	current_model = current_model->parent;
	assert(current_model!=NULL);
}

/* ----------------------------------------------------------------------------
end_smodel
---------------------------------------------------------------------------- */
void end_smodel(const string& name){
  // current_model is a StochModel -> convert this into a tree a FlatModels
  YAC_MODEL_LOG("end_smodel -- ["<<current_model->name<<"]");
  assert(false); //TODO fix stochastic
  // Check end block name matches block name
  if (name != current_model->name) {
    cerr << "end stochastic block '" << name << "' encountered in stochastic "
      "block '" << current_model->name << "'" << endl;
    exit(1);
  }

  // this is the ModelComp pointing to the StochModel
 // ModelComp *mc = current_model->node; 
  
  // point that to the expanded flat model tree
 // mc->other = current_model->expandToFlatModel();

  // and change the name of the ModelComp of this model to the name of the 
  // new (AmplModel) model. 
  // (this is a concatenation of the StochModel name and the name of the 
  // first stage)
//  mc->id = mc->other->name;

  // and go back to the parent 
  current_model = current_model->parent;
  is_stoch_model = false;
  
  assert(AmplModel::root == current_model);
  //AmplModel::root->isStochastic = true;
}

/* ------------------------------------------------------------------------
add_indexing/rem_indexing
-------------------------------------------------------------------------- */
void print_index_dummy_vars()
{
	YAC_MODEL_LOG("print_index_dummy_vars -- ");
	for(int i=0;i<index_dummy_vars.size();i++)
	{
		YAC_MODEL_LOG("["<<i<<"] "<<index_dummy_vars[i]);
	}	
}

void record_dummy_var()
{
	YAC_MODEL_LOG("record_dummy_var -- size["<<index_dummy_vars.size()<<"]");
	dummy_var_size.push_back(index_dummy_vars.size());
}

void restore_dummy_var()
{
	YAC_MODEL_LOG("restore_dummy_var -- size["<<index_dummy_vars.size()<<"]");
	print_index_dummy_vars();
	int pre_size = dummy_var_size.back();
	assert(pre_size <= index_dummy_vars.size());
	for(int i=index_dummy_vars.size()-1;i>=pre_size;i--)
	{
		YAC_MODEL_LOG("remove - "<<index_dummy_vars[i]);
	}
	dummy_var_size.pop_back();
	index_dummy_vars.resize(pre_size);
	print_index_dummy_vars();
}

bool isDummyVar(string& v)
{
	for(vector<string>::iterator it=index_dummy_vars.begin();it!=index_dummy_vars.end();it++)
	{
		if(v.compare(*it)==0)
		{
			return true;
		}
	}
	return false;
}


/* ---------------------------------------------------------------------------
Stochastic model helper functions
---------------------------------------------------------------------------- */
void addStochInfo(ModelComp *newmcs, SyntaxNode *stochopt) {
   if(stochopt) {
     bool isDet = stochopt->opCode == DETERMINISTIC;
     YAC_MODEL_LOG("isDet["<<isDet<<"] is_deterministic_glo["<<is_deterministic_glo<<"]");
     newmcs->setDeterministic(isDet || is_deterministic_glo);
     newmcs->setStageSetNode(isDet ? stages_glo : stochopt);
   } else {
      newmcs->setDeterministic(is_deterministic_glo);
      newmcs->setStageSetNode(stages_glo);
   }
}

//yyin opened,and readable
int parse_model() 
{
	int errcode = 0;
	yyin = fopen(GlobalVariables::modelfilename.c_str(),"r");
	assert(errcode==0);
	string name = "root";
	
   	AmplModel::root = new AmplModel(name,NULL,NULL);
   	current_model = AmplModel::root;
   	is_stoch_model = false;
   	is_deterministic_glo = false;
   	stages_glo = NULL;

	YAC_MODEL_LOG("starting model parser.... ");
   	errcode = yyparse();
   	assert(errcode==0);
   	YAC_MODEL_LOG("model parser finished !");
   	
   	fclose(yyin);
   	assert(errcode==0);
	return errcode;
}
