MPI Initialization succeded...
-------------------------------------------------------------------------------
Number of processors: 1
Processor 0 is y570
-------------------------------------------------------------------------------
LOG==>[0/1]-Rank [0]
LOG==>[0/1]-Size [1]
LOG==>[0/1]-hostname [y570]
LOG==>[0/1]-Debug[0]
LOG==>[0/1]-data file [msnd3_3.dat]
LOG==>[0/1]-model file [ampl_msnd.mod]
LOG==>[0/1]-out file ]
LOG==>[0/1]-Degree of Parallel[1]
LOG==>[0/1]-AmplCommand: [/home/s0965328/research/ampl-student/ampl]
LOG==>[0/1]-write matlab [0]
LOG==>[0/1]-write MPS [0]
LOG==>[0/1]-logParseModel [1]
LOG==>[0/1]-solve [0]
LOG==>[0/1]-Running PSMG with OOPS
LOG==>[0/1]-Process started on host[y570]
Parallel Problem Generator for Structure-conveying Modelling Language, version - trunk
(c) 2013 Feng Qiang, Andreas Grothey, University of Edinburgh.
Released under LGPL v3
CPU:: CLOCKS_PER_SEC [1000000]
LOG==>[0/1]-Sml processor created...scriptList[0]
LOG==>[0/1]-AmplModel -- create - name[root] 
YAC_LOG==>before model parse is done!
YAC_LOG==>setdef:[SET ID indexing_opt] - ID=[NODES] indexing_opt=[]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[274] val1:[] val2:[] val3:[]
YAC_LOG==>stochattr_opt=[]
YAC_LOG==>setattributes_opt=[ordered]
LOG==>[0/1]-Creating model component : id=NODES indexing= attribute=ordered type3
LOG==>[0/1]--- In setUpDependencies -- id=NODES
LOG==>[0/1]- dependencies in attributes: ordered
LOG==>[0/1]--- end setUpDependencies --dependencies.size=0
LOG==>[0/1]--- In addComp  -- this model:[root] level[0] add type[3]
LOG==>[0/1]--- In setUpDependencies -- id=NODES
LOG==>[0/1]- dependencies in attributes: ordered
LOG==>[0/1]--- end setUpDependencies --dependencies.size=0
LOG==>[0/1]--- End AddComp [current:root]  n_total[1]
YAC_LOG==>setdef:[SET ID indexing_opt] - ID=[ARCS] indexing_opt=[]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[274] val1:[] val2:[] val3:[]
YAC_LOG==>stochattr_opt=[]
YAC_LOG==>setattributes_opt=[ordered]
LOG==>[0/1]-Creating model component : id=ARCS indexing= attribute=ordered type3
LOG==>[0/1]--- In setUpDependencies -- id=ARCS
LOG==>[0/1]- dependencies in attributes: ordered
LOG==>[0/1]--- end setUpDependencies --dependencies.size=0
LOG==>[0/1]--- In addComp  -- this model:[root] level[0] add type[3]
LOG==>[0/1]--- In setUpDependencies -- id=ARCS
LOG==>[0/1]- dependencies in attributes: ordered
LOG==>[0/1]--- end setUpDependencies --dependencies.size=0
LOG==>[0/1]--- End AddComp [current:root]  n_total[2]
YAC_LOG==>setdef:[SET ID indexing_opt] - ID=[COMM] indexing_opt=[]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[274] val1:[] val2:[] val3:[]
YAC_LOG==>stochattr_opt=[]
YAC_LOG==>setattributes_opt=[ordered]
LOG==>[0/1]-Creating model component : id=COMM indexing= attribute=ordered type3
LOG==>[0/1]--- In setUpDependencies -- id=COMM
LOG==>[0/1]- dependencies in attributes: ordered
LOG==>[0/1]--- end setUpDependencies --dependencies.size=0
LOG==>[0/1]--- In addComp  -- this model:[root] level[0] add type[3]
LOG==>[0/1]--- In setUpDependencies -- id=COMM
LOG==>[0/1]- dependencies in attributes: ordered
LOG==>[0/1]--- end setUpDependencies --dependencies.size=0
LOG==>[0/1]--- End AddComp [current:root]  n_total[3]
YAC_LOG==>iditem : ID rule matched , ARCS
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCS]
YAC_LOG==>identifier: iditem rule matched  ARCS
LOG==>[0/1]-Finding ref:ARCS in AmplModel(context):root
LOG==>[0/1]-  -- [ARCS] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCS in current active indexings
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: ARCS refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCS
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1d80]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCS] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{ARCS}] LBR{(IDREF(0x28aac00:ARCS(0x28a1d80))())
YAC_LOG==>[add_index] - length of indexing now: 1
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>[rem_indexing] length[0]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCS] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{ARCS}] LBR{(IDREF(0x28aac00:ARCS(0x28a1d80))())
YAC_LOG==>[add_index] - length of indexing now: 1
LOG==>[0/1]-Creating model component : id=cost indexing={ARCS} attribute= type2
LOG==>[0/1]--- In setUpDependencies -- id=cost
LOG==>[0/1]- dependencies in indexing: {ARCS}
LOG==>[0/1]-  ARCS
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[root] level[0] add type[2]
LOG==>[0/1]--- In setUpDependencies -- id=cost
LOG==>[0/1]- dependencies in indexing: {ARCS}
LOG==>[0/1]-  ARCS
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:root]  n_total[4]
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>rem indexing expression to list: {ARCS}
YAC_LOG==>[rem_indexing] length[0]
YAC_LOG==>iditem : ID rule matched , ARCS
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCS]
YAC_LOG==>identifier: iditem rule matched  ARCS
LOG==>[0/1]-Finding ref:ARCS in AmplModel(context):root
LOG==>[0/1]-  -- [ARCS] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCS in current active indexings
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: ARCS refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCS
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1d80]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCS] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{ARCS}] LBR{(IDREF(0x28abd00:ARCS(0x28a1d80))())
YAC_LOG==>[add_index] - length of indexing now: 1
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>[rem_indexing] length[0]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCS] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{ARCS}] LBR{(IDREF(0x28abd00:ARCS(0x28a1d80))())
YAC_LOG==>[add_index] - length of indexing now: 1
LOG==>[0/1]-Creating model component : id=basecap indexing={ARCS} attribute= type2
LOG==>[0/1]--- In setUpDependencies -- id=basecap
LOG==>[0/1]- dependencies in indexing: {ARCS}
LOG==>[0/1]-  ARCS
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[root] level[0] add type[2]
LOG==>[0/1]--- In setUpDependencies -- id=basecap
LOG==>[0/1]- dependencies in indexing: {ARCS}
LOG==>[0/1]-  ARCS
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:root]  n_total[5]
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>rem indexing expression to list: {ARCS}
YAC_LOG==>[rem_indexing] length[0]
YAC_LOG==>iditem : ID rule matched , ARCS
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCS]
YAC_LOG==>identifier: iditem rule matched  ARCS
LOG==>[0/1]-Finding ref:ARCS in AmplModel(context):root
LOG==>[0/1]-  -- [ARCS] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCS in current active indexings
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: ARCS refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCS
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1d80]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCS] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{ARCS}] LBR{(IDREF(0x28ace60:ARCS(0x28a1d80))())
YAC_LOG==>[add_index] - length of indexing now: 1
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>[rem_indexing] length[0]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCS] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{ARCS}] LBR{(IDREF(0x28ace60:ARCS(0x28a1d80))())
YAC_LOG==>[add_index] - length of indexing now: 1
LOG==>[0/1]-Creating model component : id=arc_source indexing={ARCS} attribute= type2
LOG==>[0/1]--- In setUpDependencies -- id=arc_source
LOG==>[0/1]- dependencies in indexing: {ARCS}
LOG==>[0/1]-  ARCS
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[root] level[0] add type[2]
LOG==>[0/1]--- In setUpDependencies -- id=arc_source
LOG==>[0/1]- dependencies in indexing: {ARCS}
LOG==>[0/1]-  ARCS
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:root]  n_total[6]
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>rem indexing expression to list: {ARCS}
YAC_LOG==>[rem_indexing] length[0]
YAC_LOG==>iditem : ID rule matched , ARCS
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCS]
YAC_LOG==>identifier: iditem rule matched  ARCS
LOG==>[0/1]-Finding ref:ARCS in AmplModel(context):root
LOG==>[0/1]-  -- [ARCS] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCS in current active indexings
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: ARCS refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCS
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1d80]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCS] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{ARCS}] LBR{(IDREF(0x28adfd0:ARCS(0x28a1d80))())
YAC_LOG==>[add_index] - length of indexing now: 1
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>[rem_indexing] length[0]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCS] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{ARCS}] LBR{(IDREF(0x28adfd0:ARCS(0x28a1d80))())
YAC_LOG==>[add_index] - length of indexing now: 1
LOG==>[0/1]-Creating model component : id=arc_target indexing={ARCS} attribute= type2
LOG==>[0/1]--- In setUpDependencies -- id=arc_target
LOG==>[0/1]- dependencies in indexing: {ARCS}
LOG==>[0/1]-  ARCS
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[root] level[0] add type[2]
LOG==>[0/1]--- In setUpDependencies -- id=arc_target
LOG==>[0/1]- dependencies in indexing: {ARCS}
LOG==>[0/1]-  ARCS
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:root]  n_total[7]
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>rem indexing expression to list: {ARCS}
YAC_LOG==>[rem_indexing] length[0]
YAC_LOG==>iditem : ID rule matched , COMM
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[COMM]
YAC_LOG==>identifier: iditem rule matched  COMM
LOG==>[0/1]-Finding ref:COMM in AmplModel(context):root
LOG==>[0/1]-  -- [COMM] has an ID opCode
LOG==>[0/1]---> now Search for matches of COMM in current active indexings
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: COMM refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             COMM
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1b00]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[COMM] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{COMM}] LBR{(IDREF(0x28af100:COMM(0x28a1b00))())
YAC_LOG==>[add_index] - length of indexing now: 1
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>[rem_indexing] length[0]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[COMM] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{COMM}] LBR{(IDREF(0x28af100:COMM(0x28a1b00))())
YAC_LOG==>[add_index] - length of indexing now: 1
LOG==>[0/1]-Creating model component : id=comm_source indexing={COMM} attribute= type2
LOG==>[0/1]--- In setUpDependencies -- id=comm_source
LOG==>[0/1]- dependencies in indexing: {COMM}
LOG==>[0/1]-  COMM
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[root] level[0] add type[2]
LOG==>[0/1]--- In setUpDependencies -- id=comm_source
LOG==>[0/1]- dependencies in indexing: {COMM}
LOG==>[0/1]-  COMM
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:root]  n_total[8]
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>rem indexing expression to list: {COMM}
YAC_LOG==>[rem_indexing] length[0]
YAC_LOG==>iditem : ID rule matched , COMM
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[COMM]
YAC_LOG==>identifier: iditem rule matched  COMM
LOG==>[0/1]-Finding ref:COMM in AmplModel(context):root
LOG==>[0/1]-  -- [COMM] has an ID opCode
LOG==>[0/1]---> now Search for matches of COMM in current active indexings
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: COMM refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             COMM
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1b00]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[COMM] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{COMM}] LBR{(IDREF(0x28b0260:COMM(0x28a1b00))())
YAC_LOG==>[add_index] - length of indexing now: 1
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>[rem_indexing] length[0]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[COMM] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{COMM}] LBR{(IDREF(0x28b0260:COMM(0x28a1b00))())
YAC_LOG==>[add_index] - length of indexing now: 1
LOG==>[0/1]-Creating model component : id=comm_target indexing={COMM} attribute= type2
LOG==>[0/1]--- In setUpDependencies -- id=comm_target
LOG==>[0/1]- dependencies in indexing: {COMM}
LOG==>[0/1]-  COMM
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[root] level[0] add type[2]
LOG==>[0/1]--- In setUpDependencies -- id=comm_target
LOG==>[0/1]- dependencies in indexing: {COMM}
LOG==>[0/1]-  COMM
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:root]  n_total[9]
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>rem indexing expression to list: {COMM}
YAC_LOG==>[rem_indexing] length[0]
YAC_LOG==>iditem : ID rule matched , COMM
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[COMM]
YAC_LOG==>identifier: iditem rule matched  COMM
LOG==>[0/1]-Finding ref:COMM in AmplModel(context):root
LOG==>[0/1]-  -- [COMM] has an ID opCode
LOG==>[0/1]---> now Search for matches of COMM in current active indexings
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: COMM refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             COMM
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1b00]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[COMM] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{COMM}] LBR{(IDREF(0x28b1430:COMM(0x28a1b00))())
YAC_LOG==>[add_index] - length of indexing now: 1
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>[rem_indexing] length[0]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[COMM] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{COMM}] LBR{(IDREF(0x28b1430:COMM(0x28a1b00))())
YAC_LOG==>[add_index] - length of indexing now: 1
LOG==>[0/1]-Creating model component : id=comm_demand indexing={COMM} attribute= type2
LOG==>[0/1]--- In setUpDependencies -- id=comm_demand
LOG==>[0/1]- dependencies in indexing: {COMM}
LOG==>[0/1]-  COMM
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[root] level[0] add type[2]
LOG==>[0/1]--- In setUpDependencies -- id=comm_demand
LOG==>[0/1]- dependencies in indexing: {COMM}
LOG==>[0/1]-  COMM
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:root]  n_total[10]
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>rem indexing expression to list: {COMM}
YAC_LOG==>[rem_indexing] length[0]
YAC_LOG==>iditem : ID rule matched , COMM
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[COMM]
YAC_LOG==>identifier: iditem rule matched  COMM
LOG==>[0/1]-Finding ref:COMM in AmplModel(context):root
LOG==>[0/1]-  -- [COMM] has an ID opCode
LOG==>[0/1]---> now Search for matches of COMM in current active indexings
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: COMM refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             COMM
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1b00]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[k]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[k] val2:[COMM] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>iditem : ID rule matched , NODES
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[NODES]
YAC_LOG==>identifier: iditem rule matched  NODES
LOG==>[0/1]-Finding ref:NODES in AmplModel(context):root
LOG==>[0/1]-  -- [NODES] has an ID opCode
LOG==>[0/1]---> now Search for matches of NODES in current active indexings
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: NODES refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             NODES
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a19e0]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[i]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[i] val2:[NODES] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[359] val1:[k in COMM] val2:[i in NODES] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[k in COMM]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[k in COMM,i in NODES] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{k in COMM,i in NODES}] LBR{(COMMA(IN((ID T), IDREF(0x28b2540:COMM(0x28a1b00))()), IN((ID T), IDREF(0x28b2750:NODES(0x28a19e0))())))
YAC_LOG==>[add_index] - length of indexing now: 1
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>[rem_indexing] length[0]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[k in COMM,i in NODES] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{k in COMM,i in NODES}] LBR{(COMMA(IN((ID T), IDREF(0x28b2540:COMM(0x28a1b00))()), IN((ID T), IDREF(0x28b2750:NODES(0x28a19e0))())))
YAC_LOG==>[add_index] - length of indexing now: 1
YAC_LOG==>iditem : ID rule matched , k
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[k]
YAC_LOG==>identifier: iditem rule matched  k
LOG==>[0/1]-Finding ref:k in AmplModel(context):root
LOG==>[0/1]-  -- [k] has an ID opCode
LOG==>[0/1]---> now Search for matches of k in current active indexings
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-    k is matched by dummy var in k
YAC_LOG==>value: identifier rule matched! k
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[k] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!k
YAC_LOG==>expr_list: expr rule matched! k
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[k] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[k]
YAC_LOG==>ID comm_source [k]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[comm_source]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[comm_source] val2:[k] val3:[]
YAC_LOG==>identifier: iditem rule matched  comm_source[k]
LOG==>[0/1]-Finding ref:comm_source[k] in AmplModel(context):root
LOG==>[0/1]-  -- [comm_source[k]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of comm_source in current active indexings
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: comm_source refers to 
LOG==>[0/1]-             parameter
LOG==>[0/1]-             comm_source
LOG==>[0/1]-             {COMM}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28af460]
LOG==>[0/1]-Adding argument list to node: k
YAC_LOG==>value: identifier rule matched! comm_source[k]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[comm_source[k]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!comm_source[k]
YAC_LOG==>iditem : ID rule matched , i
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[i]
YAC_LOG==>identifier: iditem rule matched  i
LOG==>[0/1]-Finding ref:i in AmplModel(context):root
LOG==>[0/1]-  -- [i] has an ID opCode
LOG==>[0/1]---> now Search for matches of i in current active indexings
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-    i is matched by dummy var in i
YAC_LOG==>value: identifier rule matched! i
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[i] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!i
YAC_LOG==>expr_list: expr rule matched! i
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[i] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[i]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[364] val1:[i] val2:[] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[333] val1:[(i)] val2:[] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[349] val1:[comm_source[k]] val2:[ord(i)] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[349]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[364] val1:[comm_source[k] == ord(i)] val2:[] val3:[]
YAC_LOG==>iditem : ID rule matched , k
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[k]
YAC_LOG==>identifier: iditem rule matched  k
LOG==>[0/1]-Finding ref:k in AmplModel(context):root
LOG==>[0/1]-  -- [k] has an ID opCode
LOG==>[0/1]---> now Search for matches of k in current active indexings
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-    k is matched by dummy var in k
YAC_LOG==>value: identifier rule matched! k
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[k] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!k
YAC_LOG==>expr_list: expr rule matched! k
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[k] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[k]
YAC_LOG==>ID comm_demand [k]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[comm_demand]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[comm_demand] val2:[k] val3:[]
YAC_LOG==>identifier: iditem rule matched  comm_demand[k]
LOG==>[0/1]-Finding ref:comm_demand[k] in AmplModel(context):root
LOG==>[0/1]-  -- [comm_demand[k]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of comm_demand in current active indexings
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: comm_demand refers to 
LOG==>[0/1]-             parameter
LOG==>[0/1]-             comm_demand
LOG==>[0/1]-             {COMM}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28b1790]
LOG==>[0/1]-Adding argument list to node: k
YAC_LOG==>value: identifier rule matched! comm_demand[k]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[comm_demand[k]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!comm_demand[k]
YAC_LOG==>iditem : ID rule matched , k
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[k]
YAC_LOG==>identifier: iditem rule matched  k
LOG==>[0/1]-Finding ref:k in AmplModel(context):root
LOG==>[0/1]-  -- [k] has an ID opCode
LOG==>[0/1]---> now Search for matches of k in current active indexings
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-    k is matched by dummy var in k
YAC_LOG==>value: identifier rule matched! k
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[k] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!k
YAC_LOG==>expr_list: expr rule matched! k
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[k] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[k]
YAC_LOG==>ID comm_target [k]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[comm_target]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[comm_target] val2:[k] val3:[]
YAC_LOG==>identifier: iditem rule matched  comm_target[k]
LOG==>[0/1]-Finding ref:comm_target[k] in AmplModel(context):root
LOG==>[0/1]-  -- [comm_target[k]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of comm_target in current active indexings
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: comm_target refers to 
LOG==>[0/1]-             parameter
LOG==>[0/1]-             comm_target
LOG==>[0/1]-             {COMM}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28b05c0]
LOG==>[0/1]-Adding argument list to node: k
YAC_LOG==>value: identifier rule matched! comm_target[k]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[comm_target[k]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!comm_target[k]
YAC_LOG==>iditem : ID rule matched , i
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[i]
YAC_LOG==>identifier: iditem rule matched  i
LOG==>[0/1]-Finding ref:i in AmplModel(context):root
LOG==>[0/1]-  -- [i] has an ID opCode
LOG==>[0/1]---> now Search for matches of i in current active indexings
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-    i is matched by dummy var in i
YAC_LOG==>value: identifier rule matched! i
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[i] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!i
YAC_LOG==>expr_list: expr rule matched! i
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[i] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[i]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[364] val1:[i] val2:[] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[333] val1:[(i)] val2:[] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[349] val1:[comm_target[k]] val2:[ord(i)] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[349]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[364] val1:[comm_target[k] == ord(i)] val2:[] val3:[]
YAC_LOG==>iditem : ID rule matched , k
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[k]
YAC_LOG==>identifier: iditem rule matched  k
LOG==>[0/1]-Finding ref:k in AmplModel(context):root
LOG==>[0/1]-  -- [k] has an ID opCode
LOG==>[0/1]---> now Search for matches of k in current active indexings
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-    k is matched by dummy var in k
YAC_LOG==>value: identifier rule matched! k
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[k] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!k
YAC_LOG==>expr_list: expr rule matched! k
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[k] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[k]
YAC_LOG==>ID comm_demand [k]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[comm_demand]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[comm_demand] val2:[k] val3:[]
YAC_LOG==>identifier: iditem rule matched  comm_demand[k]
LOG==>[0/1]-Finding ref:comm_demand[k] in AmplModel(context):root
LOG==>[0/1]-  -- [comm_demand[k]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of comm_demand in current active indexings
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: comm_demand refers to 
LOG==>[0/1]-             parameter
LOG==>[0/1]-             comm_demand
LOG==>[0/1]-             {COMM}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28b1790]
LOG==>[0/1]-Adding argument list to node: k
YAC_LOG==>value: identifier rule matched! comm_demand[k]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[comm_demand[k]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!comm_demand[k]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[45] val1:[comm_demand[k]] val2:[] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[45]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[-99] val1:[] val2:[] val3:[]
LOG==>[0/1]-ValueNode constructor --- opCode [-99] value[0]
YAC_LOG==>expr: value rule matched!0
LOG==>[0/1]-SyntaxNode constructor  --- 3<- opCode[313] val1:[(comm_target[k] == ord(i))] val2:[- comm_demand[k]] val3:[0]
LOG==>[0/1]-SyntaxNode constructor  --- 3<- opCode[313] val1:[(comm_source[k] == ord(i))] val2:[comm_demand[k]] val3:[if (comm_target[k] == ord(i)) then - comm_demand[k] else 0]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[366] val1:[if (comm_source[k] == ord(i)) then comm_demand[k] else if (comm_target[k] == ord(i)) then - comm_demand[k] else 0] val2:[] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[366]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[:= if (comm_source[k] == ord(i)) then comm_demand[k] else if (comm_target[k] == ord(i)) then - comm_demand[k] else 0] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[:= if (comm_source[k] == ord(i)) then comm_demand[k] else if (comm_target[k] == ord(i)) then - comm_demand[k] else 0]
LOG==>[0/1]-Creating model component : id=b indexing={k in COMM,i in NODES} attribute=:= if (comm_source[k] == ord(i)) then comm_demand[k] else if (comm_target[k] == ord(i)) then - comm_demand[k] else 0 type2
LOG==>[0/1]--- In setUpDependencies -- id=b
LOG==>[0/1]- dependencies in indexing: {k in COMM,i in NODES}
LOG==>[0/1]-  COMM
LOG==>[0/1]-  NODES
LOG==>[0/1]- dependencies in attributes: := if (comm_source[k] == ord(i)) then comm_demand[k] else if (comm_target[k] == ord(i)) then - comm_demand[k] else 0
LOG==>[0/1]-  comm_source
LOG==>[0/1]-  comm_demand
LOG==>[0/1]-  comm_target
LOG==>[0/1]--- end setUpDependencies --dependencies.size=5
LOG==>[0/1]--- In addComp  -- this model:[root] level[0] add type[2]
LOG==>[0/1]--- In setUpDependencies -- id=b
LOG==>[0/1]- dependencies in indexing: {k in COMM,i in NODES}
LOG==>[0/1]-  COMM
LOG==>[0/1]-  NODES
LOG==>[0/1]- dependencies in attributes: := if (comm_source[k] == ord(i)) then comm_demand[k] else if (comm_target[k] == ord(i)) then - comm_demand[k] else 0
LOG==>[0/1]-  comm_source
LOG==>[0/1]-  comm_demand
LOG==>[0/1]-  comm_target
LOG==>[0/1]--- end setUpDependencies --dependencies.size=5
LOG==>[0/1]--- End AddComp [current:root]  n_total[11]
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>rem indexing expression to list: {k in COMM,i in NODES}
YAC_LOG==>[rem_indexing] length[0]
YAC_LOG==>iditem : ID rule matched , ARCS
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCS]
YAC_LOG==>identifier: iditem rule matched  ARCS
LOG==>[0/1]-Finding ref:ARCS in AmplModel(context):root
LOG==>[0/1]-  -- [ARCS] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCS in current active indexings
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: ARCS refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCS
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1d80]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCS] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{ARCS}] LBR{(IDREF(0x28b4ca0:ARCS(0x28a1d80))())
YAC_LOG==>[add_index] - length of indexing now: 1
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>[rem_indexing] length[0]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCS] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{ARCS}] LBR{(IDREF(0x28b4ca0:ARCS(0x28a1d80))())
YAC_LOG==>[add_index] - length of indexing now: 1
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[-99] val1:[] val2:[] val3:[]
LOG==>[0/1]-ValueNode constructor --- opCode [-99] value[0]
YAC_LOG==>expr: value rule matched!0
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[348] val1:[0] val2:[] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[348]
LOG==>[0/1]-In addItemToListOrCreate -- 
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[>= 0] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[>= 0]
LOG==>[0/1]-Creating model component : id=sparecap indexing={ARCS} attribute=>= 0 type0
LOG==>[0/1]--- In setUpDependencies -- id=sparecap
LOG==>[0/1]- dependencies in indexing: {ARCS}
LOG==>[0/1]-  ARCS
LOG==>[0/1]- dependencies in attributes: >= 0
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[root] level[0] add type[0]
LOG==>[0/1]--- In setUpDependencies -- id=sparecap
LOG==>[0/1]- dependencies in indexing: {ARCS}
LOG==>[0/1]-  ARCS
LOG==>[0/1]- dependencies in attributes: >= 0
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:root]  n_total[12]
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>rem indexing expression to list: {ARCS}
YAC_LOG==>[rem_indexing] length[0]
YAC_LOG==>iditem : ID rule matched , ARCS
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCS]
YAC_LOG==>identifier: iditem rule matched  ARCS
LOG==>[0/1]-Finding ref:ARCS in AmplModel(context):root
LOG==>[0/1]-  -- [ARCS] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCS in current active indexings
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: ARCS refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCS
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1d80]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[a]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[a] val2:[ARCS] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[a in ARCS] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{a in ARCS}] LBR{(IN((ID T), IDREF(0x28b5ee0:ARCS(0x28a1d80))()))
YAC_LOG==>[add_index] - length of indexing now: 1
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>[rem_indexing] length[0]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[a in ARCS] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{a in ARCS}] LBR{(IN((ID T), IDREF(0x28b5ee0:ARCS(0x28a1d80))()))
YAC_LOG==>[add_index] - length of indexing now: 1
LOG==>[0/1]-AmplModel -- create - name[MCNFArcs] 
LOG==>[0/1]-Start Model: MCNFArcs {a in ARCS}
LOG==>[0/1]-Creating model component : id=MCNFArcs indexing={a in ARCS} attribute= type6
LOG==>[0/1]--- In setUpDependencies -- id=MCNFArcs
LOG==>[0/1]- dependencies in indexing: {a in ARCS}
LOG==>[0/1]-  ARCS
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[root] level[0] add type[6]
LOG==>[0/1]--- In setUpDependencies -- id=MCNFArcs
LOG==>[0/1]- dependencies in indexing: {a in ARCS}
LOG==>[0/1]-  ARCS
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:root]  n_total[13]
YAC_LOG==>setdef:[SET ID indexing_opt] - ID=[ARCSDIFF] indexing_opt=[]
YAC_LOG==>iditem : ID rule matched , ARCS
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCS]
YAC_LOG==>identifier: iditem rule matched  ARCS
LOG==>[0/1]-Finding ref:ARCS in AmplModel(context):MCNFArcs
LOG==>[0/1]-  -- [ARCS] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCS in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]---> continue searching in this_context[MCNFArcs]
LOG==>[0/1]-Found Match: ARCS refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCS
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1d80]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>iditem : ID rule matched , a
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[a]
YAC_LOG==>identifier: iditem rule matched  a
LOG==>[0/1]-Finding ref:a in AmplModel(context):MCNFArcs
LOG==>[0/1]-  -- [a] has an ID opCode
LOG==>[0/1]---> now Search for matches of a in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-    a is matched by dummy var in a
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>setexpression: LBRACE setexpression RBRACE -- rule matched
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[a] val2:[] val3:[]
LOG==>[0/1]-SetNode constructor called --opCode[357]
LOG==>[0/1]-ListSet constructor called  --- opCode[357] list[a]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[353] val1:[ARCS] val2:[{a}] val3:[]
LOG==>[0/1]-SetNode constructor called --opCode[353]
LOG==>[0/1]-CompositeSet constructor called  -- opCode[353]
YAC_LOG==>match setexpression define rule
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[366] val1:[ARCS diff {a}] val2:[] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[366]
YAC_LOG==>stochattr_opt=[]
YAC_LOG==>setattributes_opt=[:= ARCS diff {a}]
LOG==>[0/1]-Creating model component : id=ARCSDIFF indexing= attribute=:= ARCS diff {a} type3
LOG==>[0/1]--- In setUpDependencies -- id=ARCSDIFF
LOG==>[0/1]- dependencies in attributes: := ARCS diff {a}
LOG==>[0/1]-  ARCS
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[MCNFArcs] level[1] add type[3]
LOG==>[0/1]--- In setUpDependencies -- id=ARCSDIFF
LOG==>[0/1]- dependencies in attributes: := ARCS diff {a}
LOG==>[0/1]-  ARCS
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:MCNFArcs]  n_total[1]
YAC_LOG==>iditem : ID rule matched , COMM
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[COMM]
YAC_LOG==>identifier: iditem rule matched  COMM
LOG==>[0/1]-Finding ref:COMM in AmplModel(context):MCNFArcs
LOG==>[0/1]-  -- [COMM] has an ID opCode
LOG==>[0/1]---> now Search for matches of COMM in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]---> continue searching in this_context[MCNFArcs]
LOG==>[0/1]-Found Match: COMM refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             COMM
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1b00]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[k]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[k] val2:[COMM] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[k in COMM] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{k in COMM}] LBR{(IN((ID T), IDREF(0x28b8250:COMM(0x28a1b00))()))
YAC_LOG==>[add_index] - length of indexing now: 2
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>[rem_indexing] length[1]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[k in COMM] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{k in COMM}] LBR{(IN((ID T), IDREF(0x28b8250:COMM(0x28a1b00))()))
YAC_LOG==>[add_index] - length of indexing now: 2
LOG==>[0/1]-AmplModel -- create - name[Net] 
LOG==>[0/1]-Start Model: Net {k in COMM}
LOG==>[0/1]-Creating model component : id=Net indexing={k in COMM} attribute= type6
LOG==>[0/1]--- In setUpDependencies -- id=Net
LOG==>[0/1]- dependencies in indexing: {k in COMM}
LOG==>[0/1]-  COMM
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[MCNFArcs] level[1] add type[6]
LOG==>[0/1]--- In setUpDependencies -- id=Net
LOG==>[0/1]- dependencies in indexing: {k in COMM}
LOG==>[0/1]-  COMM
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:MCNFArcs]  n_total[2]
YAC_LOG==>iditem : ID rule matched , ARCSDIFF
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCSDIFF]
YAC_LOG==>identifier: iditem rule matched  ARCSDIFF
LOG==>[0/1]-Finding ref:ARCSDIFF in AmplModel(context):Net
LOG==>[0/1]-  -- [ARCSDIFF] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCSDIFF in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: ARCSDIFF refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCSDIFF
LOG==>[0/1]-             := ARCS diff {a}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28b7420]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCSDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{ARCSDIFF}] LBR{(IDREF(0x28b95f0:ARCSDIFF(0x28b7420))())
YAC_LOG==>[add_index] - length of indexing now: 3
YAC_LOG==>[rem_indexing] length[3]
YAC_LOG==>[rem_indexing] length[2]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCSDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{ARCSDIFF}] LBR{(IDREF(0x28b95f0:ARCSDIFF(0x28b7420))())
YAC_LOG==>[add_index] - length of indexing now: 3
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[-99] val1:[] val2:[] val3:[]
LOG==>[0/1]-ValueNode constructor --- opCode [-99] value[0]
YAC_LOG==>expr: value rule matched!0
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[348] val1:[0] val2:[] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[348]
LOG==>[0/1]-In addItemToListOrCreate -- 
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[>= 0] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[>= 0]
LOG==>[0/1]-Creating model component : id=Flow indexing={ARCSDIFF} attribute=>= 0 type0
LOG==>[0/1]--- In setUpDependencies -- id=Flow
LOG==>[0/1]- dependencies in indexing: {ARCSDIFF}
LOG==>[0/1]-  ARCSDIFF
LOG==>[0/1]- dependencies in attributes: >= 0
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[Net] level[2] add type[0]
LOG==>[0/1]--- In setUpDependencies -- id=Flow
LOG==>[0/1]- dependencies in indexing: {ARCSDIFF}
LOG==>[0/1]-  ARCSDIFF
LOG==>[0/1]- dependencies in attributes: >= 0
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:Net]  n_total[1]
YAC_LOG==>[rem_indexing] length[3]
YAC_LOG==>rem indexing expression to list: {ARCSDIFF}
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>iditem : ID rule matched , NODES
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[NODES]
YAC_LOG==>identifier: iditem rule matched  NODES
LOG==>[0/1]-Finding ref:NODES in AmplModel(context):Net
LOG==>[0/1]-  -- [NODES] has an ID opCode
LOG==>[0/1]---> now Search for matches of NODES in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: NODES refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             NODES
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a19e0]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[i]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[i] val2:[NODES] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[i in NODES] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{i in NODES}] LBR{(IN((ID T), IDREF(0x28ba850:NODES(0x28a19e0))()))
YAC_LOG==>[add_index] - length of indexing now: 3
YAC_LOG==>[rem_indexing] length[3]
YAC_LOG==>[rem_indexing] length[2]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[i in NODES] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>subject to rule matched - ID[FlowBalance]
YAC_LOG==>[add_index] - indexing:[{i in NODES}] LBR{(IN((ID T), IDREF(0x28ba850:NODES(0x28a19e0))()))
YAC_LOG==>[add_index] - length of indexing now: 3
YAC_LOG==>iditem : ID rule matched , ARCSDIFF
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCSDIFF]
YAC_LOG==>identifier: iditem rule matched  ARCSDIFF
LOG==>[0/1]-Finding ref:ARCSDIFF in AmplModel(context):Net
LOG==>[0/1]-  -- [ARCSDIFF] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCSDIFF in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: ARCSDIFF refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCSDIFF
LOG==>[0/1]-             := ARCS diff {a}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28b7420]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[j] val2:[ARCSDIFF] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[j in ARCSDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{j in ARCSDIFF}] LBR{(IN((ID T), IDREF(0x28bab40:ARCSDIFF(0x28b7420))()))
YAC_LOG==>[add_index] - length of indexing now: 4
YAC_LOG==>iditem : ID rule matched , j
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
YAC_LOG==>identifier: iditem rule matched  j
LOG==>[0/1]-Finding ref:j in AmplModel(context):Net
LOG==>[0/1]-  -- [j] has an ID opCode
LOG==>[0/1]---> now Search for matches of j in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-    j is matched by dummy var in j
YAC_LOG==>value: identifier rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[j] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!j
YAC_LOG==>expr_list: expr rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[j] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[j]
YAC_LOG==>ID arc_target [j]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[arc_target]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[arc_target] val2:[j] val3:[]
YAC_LOG==>identifier: iditem rule matched  arc_target[j]
LOG==>[0/1]-Finding ref:arc_target[j] in AmplModel(context):Net
LOG==>[0/1]-  -- [arc_target[j]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of arc_target in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: arc_target refers to 
LOG==>[0/1]-             parameter
LOG==>[0/1]-             arc_target
LOG==>[0/1]-             {ARCS}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28ae320]
LOG==>[0/1]-Adding argument list to node: j
YAC_LOG==>value: identifier rule matched! arc_target[j]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[arc_target[j]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!arc_target[j]
YAC_LOG==>iditem : ID rule matched , i
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[i]
YAC_LOG==>identifier: iditem rule matched  i
LOG==>[0/1]-Finding ref:i in AmplModel(context):Net
LOG==>[0/1]-  -- [i] has an ID opCode
LOG==>[0/1]---> now Search for matches of i in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-    i is matched by dummy var in i
YAC_LOG==>value: identifier rule matched! i
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[i] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!i
YAC_LOG==>expr_list: expr rule matched! i
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[i] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[i]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[364] val1:[i] val2:[] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[333] val1:[(i)] val2:[] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[349] val1:[arc_target[j]] val2:[ord(i)] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[349]
YAC_LOG==>[rem_indexing] length[4]
YAC_LOG==>[rem_indexing] length[3]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[363] val1:[j in ARCSDIFF] val2:[arc_target[j] == ord(i)] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[j in ARCSDIFF: arc_target[j] == ord(i)] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{j in ARCSDIFF: arc_target[j] == ord(i)}] LBR{(COLON(IN((ID T), IDREF(0x28bab40:ARCSDIFF(0x28b7420))()), "349"("0"(IDREF(0x28bb1f0:arc_target(0x28ae320))("0"((ID T)))), "333"(LBR((COMMA("0"((ID T))))))))
YAC_LOG==>[add_index] - length of indexing now: 4
YAC_LOG==>iditem : ID rule matched , j
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
YAC_LOG==>identifier: iditem rule matched  j
LOG==>[0/1]-Finding ref:j in AmplModel(context):Net
LOG==>[0/1]-  -- [j] has an ID opCode
LOG==>[0/1]---> now Search for matches of j in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-    j is matched by dummy var in j
YAC_LOG==>value: identifier rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[j] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!j
YAC_LOG==>expr_list: expr rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[j] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[j]
YAC_LOG==>ID Flow [j]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[Flow]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[Flow] val2:[j] val3:[]
YAC_LOG==>identifier: iditem rule matched  Flow[j]
LOG==>[0/1]-Finding ref:Flow[j] in AmplModel(context):Net
LOG==>[0/1]-  -- [Flow[j]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of Flow in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: Flow refers to 
LOG==>[0/1]-             variable
LOG==>[0/1]-             Flow
LOG==>[0/1]-             {ARCSDIFF}
LOG==>[0/1]-             >= 0
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28b9a10]
LOG==>[0/1]-Adding argument list to node: j
YAC_LOG==>value: identifier rule matched! Flow[j]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[Flow[j]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!Flow[j]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[342] val1:[{j in ARCSDIFF: arc_target[j] == ord(i)}] val2:[Flow[j]] val3:[]
YAC_LOG==>[rem_indexing] length[4]
YAC_LOG==>rem indexing expression to list: {j in ARCSDIFF: arc_target[j] == ord(i)}
YAC_LOG==>[rem_indexing] length[3]
YAC_LOG==>iditem : ID rule matched , ARCSDIFF
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCSDIFF]
YAC_LOG==>identifier: iditem rule matched  ARCSDIFF
LOG==>[0/1]-Finding ref:ARCSDIFF in AmplModel(context):Net
LOG==>[0/1]-  -- [ARCSDIFF] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCSDIFF in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: ARCSDIFF refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCSDIFF
LOG==>[0/1]-             := ARCS diff {a}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28b7420]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[x]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[x] val2:[ARCSDIFF] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[x in ARCSDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{x in ARCSDIFF}] LBR{(IN((ID T), IDREF(0x28bb9e0:ARCSDIFF(0x28b7420))()))
YAC_LOG==>[add_index] - length of indexing now: 4
YAC_LOG==>iditem : ID rule matched , x
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[x]
YAC_LOG==>identifier: iditem rule matched  x
LOG==>[0/1]-Finding ref:x in AmplModel(context):Net
LOG==>[0/1]-  -- [x] has an ID opCode
LOG==>[0/1]---> now Search for matches of x in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-Found dummy variable: x
LOG==>[0/1]-    x is matched by dummy var in x
YAC_LOG==>value: identifier rule matched! x
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[x] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!x
YAC_LOG==>expr_list: expr rule matched! x
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[x] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[x]
YAC_LOG==>ID arc_source [x]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[arc_source]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[arc_source] val2:[x] val3:[]
YAC_LOG==>identifier: iditem rule matched  arc_source[x]
LOG==>[0/1]-Finding ref:arc_source[x] in AmplModel(context):Net
LOG==>[0/1]-  -- [arc_source[x]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of arc_source in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-Found dummy variable: x
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: arc_source refers to 
LOG==>[0/1]-             parameter
LOG==>[0/1]-             arc_source
LOG==>[0/1]-             {ARCS}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28ad1c0]
LOG==>[0/1]-Adding argument list to node: x
YAC_LOG==>value: identifier rule matched! arc_source[x]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[arc_source[x]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!arc_source[x]
YAC_LOG==>iditem : ID rule matched , i
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[i]
YAC_LOG==>identifier: iditem rule matched  i
LOG==>[0/1]-Finding ref:i in AmplModel(context):Net
LOG==>[0/1]-  -- [i] has an ID opCode
LOG==>[0/1]---> now Search for matches of i in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-    i is matched by dummy var in i
YAC_LOG==>value: identifier rule matched! i
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[i] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!i
YAC_LOG==>expr_list: expr rule matched! i
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[i] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[i]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[364] val1:[i] val2:[] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[333] val1:[(i)] val2:[] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[349] val1:[arc_source[x]] val2:[ord(i)] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[349]
YAC_LOG==>[rem_indexing] length[4]
YAC_LOG==>[rem_indexing] length[3]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[363] val1:[x in ARCSDIFF] val2:[arc_source[x] == ord(i)] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[x in ARCSDIFF: arc_source[x] == ord(i)] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{x in ARCSDIFF: arc_source[x] == ord(i)}] LBR{(COLON(IN((ID T), IDREF(0x28bb9e0:ARCSDIFF(0x28b7420))()), "349"("0"(IDREF(0x28bc310:arc_source(0x28ad1c0))("0"((ID T)))), "333"(LBR((COMMA("0"((ID T))))))))
YAC_LOG==>[add_index] - length of indexing now: 4
YAC_LOG==>iditem : ID rule matched , x
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[x]
YAC_LOG==>identifier: iditem rule matched  x
LOG==>[0/1]-Finding ref:x in AmplModel(context):Net
LOG==>[0/1]-  -- [x] has an ID opCode
LOG==>[0/1]---> now Search for matches of x in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-Found dummy variable: x
LOG==>[0/1]-    x is matched by dummy var in x
YAC_LOG==>value: identifier rule matched! x
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[x] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!x
YAC_LOG==>expr_list: expr rule matched! x
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[x] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[x]
YAC_LOG==>ID Flow [x]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[Flow]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[Flow] val2:[x] val3:[]
YAC_LOG==>identifier: iditem rule matched  Flow[x]
LOG==>[0/1]-Finding ref:Flow[x] in AmplModel(context):Net
LOG==>[0/1]-  -- [Flow[x]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of Flow in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-Found dummy variable: x
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: Flow refers to 
LOG==>[0/1]-             variable
LOG==>[0/1]-             Flow
LOG==>[0/1]-             {ARCSDIFF}
LOG==>[0/1]-             >= 0
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28b9a10]
LOG==>[0/1]-Adding argument list to node: x
YAC_LOG==>value: identifier rule matched! Flow[x]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[Flow[x]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!Flow[x]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[342] val1:[{x in ARCSDIFF: arc_source[x] == ord(i)}] val2:[Flow[x]] val3:[]
YAC_LOG==>[rem_indexing] length[4]
YAC_LOG==>rem indexing expression to list: {x in ARCSDIFF: arc_source[x] == ord(i)}
YAC_LOG==>[rem_indexing] length[3]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[45] val1:[sum {j in ARCSDIFF: arc_target[j] == ord(i)}Flow[j]] val2:[sum {x in ARCSDIFF: arc_source[x] == ord(i)}Flow[x]] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[45]
YAC_LOG==>iditem : ID rule matched , k
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[k]
YAC_LOG==>identifier: iditem rule matched  k
LOG==>[0/1]-Finding ref:k in AmplModel(context):Net
LOG==>[0/1]-  -- [k] has an ID opCode
LOG==>[0/1]---> now Search for matches of k in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-    k is matched by dummy var in k
YAC_LOG==>value: identifier rule matched! k
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[k] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!k
YAC_LOG==>expr_list: expr rule matched! k
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[k] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[k]
YAC_LOG==>iditem : ID rule matched , i
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[i]
YAC_LOG==>identifier: iditem rule matched  i
LOG==>[0/1]-Finding ref:i in AmplModel(context):Net
LOG==>[0/1]-  -- [i] has an ID opCode
LOG==>[0/1]---> now Search for matches of i in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-    i is matched by dummy var in i
YAC_LOG==>value: identifier rule matched! i
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[i] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!i
YAC_LOG==>ID b [k,i]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[b]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[b] val2:[k,i] val3:[]
YAC_LOG==>identifier: iditem rule matched  b[k,i]
LOG==>[0/1]-Finding ref:b[k,i] in AmplModel(context):Net
LOG==>[0/1]-  -- [b[k,i]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of b in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: b refers to 
LOG==>[0/1]-             parameter
LOG==>[0/1]-             b
LOG==>[0/1]-             {k in COMM,i in NODES}
LOG==>[0/1]-             := if (comm_source[k] == ord(i)) then comm_demand[k] else if (comm_target[k] == ord(i)) then - comm_demand[k] else 0
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28b3db0]
LOG==>[0/1]-Adding argument list to node: k,i
YAC_LOG==>value: identifier rule matched! b[k,i]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[b[k,i]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!b[k,i]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[383] val1:[sum {j in ARCSDIFF: arc_target[j] == ord(i)}Flow[j] - sum {x in ARCSDIFF: arc_source[x] == ord(i)}Flow[x]] val2:[b[k,i]] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[383]
YAC_LOG==>subject to rule part2
YAC_LOG==>non-stoch model subject to - 
LOG==>[0/1]-Creating model component : id=FlowBalance indexing={i in NODES} attribute=sum {j in ARCSDIFF: arc_target[j] == ord(i)}Flow[j] - sum {x in ARCSDIFF: arc_source[x] == ord(i)}Flow[x] = b[k,i] type1
LOG==>[0/1]--- In setUpDependencies -- id=FlowBalance
LOG==>[0/1]- dependencies in indexing: {i in NODES}
LOG==>[0/1]-  NODES
LOG==>[0/1]- dependencies in attributes: sum {j in ARCSDIFF: arc_target[j] == ord(i)}Flow[j] - sum {x in ARCSDIFF: arc_source[x] == ord(i)}Flow[x] = b[k,i]
LOG==>[0/1]-  ARCSDIFF
LOG==>[0/1]-  arc_target
LOG==>[0/1]-  Flow
LOG==>[0/1]-  arc_source
LOG==>[0/1]-  b
LOG==>[0/1]--- end setUpDependencies --dependencies.size=6
LOG==>[0/1]--- In addComp  -- this model:[Net] level[2] add type[1]
LOG==>[0/1]--- In setUpDependencies -- id=FlowBalance
LOG==>[0/1]- dependencies in indexing: {i in NODES}
LOG==>[0/1]-  NODES
LOG==>[0/1]- dependencies in attributes: sum {j in ARCSDIFF: arc_target[j] == ord(i)}Flow[j] - sum {x in ARCSDIFF: arc_source[x] == ord(i)}Flow[x] = b[k,i]
LOG==>[0/1]-  ARCSDIFF
LOG==>[0/1]-  arc_target
LOG==>[0/1]-  Flow
LOG==>[0/1]-  arc_source
LOG==>[0/1]-  b
LOG==>[0/1]--- end setUpDependencies --dependencies.size=6
LOG==>[0/1]--- End AddComp [current:Net]  n_total[2]
YAC_LOG==>[rem_indexing] length[3]
YAC_LOG==>rem indexing expression to list: {i in NODES}
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>iditem : ID rule matched , ARCSDIFF
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCSDIFF]
YAC_LOG==>identifier: iditem rule matched  ARCSDIFF
LOG==>[0/1]-Finding ref:ARCSDIFF in AmplModel(context):MCNFArcs
LOG==>[0/1]-  -- [ARCSDIFF] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCSDIFF in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]---> continue searching in this_context[MCNFArcs]
LOG==>[0/1]-Found Match: ARCSDIFF refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCSDIFF
LOG==>[0/1]-             := ARCS diff {a}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28b7420]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCSDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{ARCSDIFF}] LBR{(IDREF(0x28bda20:ARCSDIFF(0x28b7420))())
YAC_LOG==>[add_index] - length of indexing now: 2
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>[rem_indexing] length[1]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCSDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{ARCSDIFF}] LBR{(IDREF(0x28bda20:ARCSDIFF(0x28b7420))())
YAC_LOG==>[add_index] - length of indexing now: 2
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[-99] val1:[] val2:[] val3:[]
LOG==>[0/1]-ValueNode constructor --- opCode [-99] value[0]
YAC_LOG==>expr: value rule matched!0
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[348] val1:[0] val2:[] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[348]
LOG==>[0/1]-In addItemToListOrCreate -- 
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[>= 0] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[>= 0]
LOG==>[0/1]-Creating model component : id=capslack indexing={ARCSDIFF} attribute=>= 0 type0
LOG==>[0/1]--- In setUpDependencies -- id=capslack
LOG==>[0/1]- dependencies in indexing: {ARCSDIFF}
LOG==>[0/1]-  ARCSDIFF
LOG==>[0/1]- dependencies in attributes: >= 0
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[MCNFArcs] level[1] add type[0]
LOG==>[0/1]--- In setUpDependencies -- id=capslack
LOG==>[0/1]- dependencies in indexing: {ARCSDIFF}
LOG==>[0/1]-  ARCSDIFF
LOG==>[0/1]- dependencies in attributes: >= 0
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:MCNFArcs]  n_total[3]
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>rem indexing expression to list: {ARCSDIFF}
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>iditem : ID rule matched , ARCSDIFF
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCSDIFF]
YAC_LOG==>identifier: iditem rule matched  ARCSDIFF
LOG==>[0/1]-Finding ref:ARCSDIFF in AmplModel(context):MCNFArcs
LOG==>[0/1]-  -- [ARCSDIFF] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCSDIFF in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]---> continue searching in this_context[MCNFArcs]
LOG==>[0/1]-Found Match: ARCSDIFF refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCSDIFF
LOG==>[0/1]-             := ARCS diff {a}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28b7420]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[j] val2:[ARCSDIFF] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[j in ARCSDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{j in ARCSDIFF}] LBR{(IN((ID T), IDREF(0x28bebf0:ARCSDIFF(0x28b7420))()))
YAC_LOG==>[add_index] - length of indexing now: 2
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>[rem_indexing] length[1]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[j in ARCSDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>subject to rule matched - ID[Capacity]
YAC_LOG==>[add_index] - indexing:[{j in ARCSDIFF}] LBR{(IN((ID T), IDREF(0x28bebf0:ARCSDIFF(0x28b7420))()))
YAC_LOG==>[add_index] - length of indexing now: 2
YAC_LOG==>iditem : ID rule matched , COMM
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[COMM]
YAC_LOG==>identifier: iditem rule matched  COMM
LOG==>[0/1]-Finding ref:COMM in AmplModel(context):MCNFArcs
LOG==>[0/1]-  -- [COMM] has an ID opCode
LOG==>[0/1]---> now Search for matches of COMM in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]---> continue searching in this_context[MCNFArcs]
LOG==>[0/1]-Found Match: COMM refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             COMM
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1b00]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[k]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[k] val2:[COMM] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[k in COMM] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{k in COMM}] LBR{(IN((ID T), IDREF(0x28bf2a0:COMM(0x28a1b00))()))
YAC_LOG==>[add_index] - length of indexing now: 3
YAC_LOG==>[rem_indexing] length[3]
YAC_LOG==>[rem_indexing] length[2]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[k in COMM] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{k in COMM}] LBR{(IN((ID T), IDREF(0x28bf2a0:COMM(0x28a1b00))()))
YAC_LOG==>[add_index] - length of indexing now: 3
YAC_LOG==>iditem : ID rule matched , k
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[k]
YAC_LOG==>identifier: iditem rule matched  k
LOG==>[0/1]-Finding ref:k in AmplModel(context):MCNFArcs
LOG==>[0/1]-  -- [k] has an ID opCode
LOG==>[0/1]---> now Search for matches of k in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-    k is matched by dummy var in k
YAC_LOG==>value: identifier rule matched! k
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[k] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!k
YAC_LOG==>expr_list: expr rule matched! k
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[k] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[k]
YAC_LOG==>ID Net [k]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[Net]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[Net] val2:[k] val3:[]
YAC_LOG==>identifier: iditem rule matched  Net[k]
LOG==>[0/1]-Finding ref:Net[k] in AmplModel(context):MCNFArcs
LOG==>[0/1]-  -- [Net[k]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of Net in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]---> continue searching in this_context[MCNFArcs]
LOG==>[0/1]-Found Match: Net refers to 
LOG==>[0/1]-             submodel
LOG==>[0/1]-             Net
LOG==>[0/1]-             {k in COMM}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[374] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[374] ModelComp[0x28b8610]
LOG==>[0/1]-Adding argument list to node: k
YAC_LOG==>iditem : ID rule matched , j
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
YAC_LOG==>identifier: iditem rule matched  j
LOG==>[0/1]-Finding ref:j in AmplModel(context):MCNFArcs
LOG==>[0/1]-  -- [j] has an ID opCode
LOG==>[0/1]---> now Search for matches of j in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-    j is matched by dummy var in j
YAC_LOG==>value: identifier rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[j] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!j
YAC_LOG==>expr_list: expr rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[j] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[j]
YAC_LOG==>ID Flow [j]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[Flow]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[Flow] val2:[j] val3:[]
LOG==>[0/1]-Finding ref:Flow[j] in AmplModel(context):Net
LOG==>[0/1]-  -- [Flow[j]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of Flow in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: Flow refers to 
LOG==>[0/1]-             variable
LOG==>[0/1]-             Flow
LOG==>[0/1]-             {ARCSDIFF}
LOG==>[0/1]-             >= 0
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28b9a10]
LOG==>[0/1]-Adding argument list to node: j
YAC_LOG==>Merge identifier:Net-----> iditem:Flow[]
YAC_LOG==>value: identifier rule matched! Flow[k,j]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[Flow[k,j]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!Flow[k,j]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[342] val1:[{k in COMM}] val2:[Flow[k,j]] val3:[]
YAC_LOG==>[rem_indexing] length[3]
YAC_LOG==>rem indexing expression to list: {k in COMM}
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>iditem : ID rule matched , j
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
YAC_LOG==>identifier: iditem rule matched  j
LOG==>[0/1]-Finding ref:j in AmplModel(context):MCNFArcs
LOG==>[0/1]-  -- [j] has an ID opCode
LOG==>[0/1]---> now Search for matches of j in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-    j is matched by dummy var in j
YAC_LOG==>value: identifier rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[j] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!j
YAC_LOG==>expr_list: expr rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[j] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[j]
YAC_LOG==>ID capslack [j]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[capslack]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[capslack] val2:[j] val3:[]
YAC_LOG==>identifier: iditem rule matched  capslack[j]
LOG==>[0/1]-Finding ref:capslack[j] in AmplModel(context):MCNFArcs
LOG==>[0/1]-  -- [capslack[j]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of capslack in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]---> continue searching in this_context[MCNFArcs]
LOG==>[0/1]-Found Match: capslack refers to 
LOG==>[0/1]-             variable
LOG==>[0/1]-             capslack
LOG==>[0/1]-             {ARCSDIFF}
LOG==>[0/1]-             >= 0
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28bddc0]
LOG==>[0/1]-Adding argument list to node: j
YAC_LOG==>value: identifier rule matched! capslack[j]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[capslack[j]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!capslack[j]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[43] val1:[sum {k in COMM}Flow[k,j]] val2:[capslack[j]] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[43]
YAC_LOG==>iditem : ID rule matched , j
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
YAC_LOG==>identifier: iditem rule matched  j
LOG==>[0/1]-Finding ref:j in AmplModel(context):MCNFArcs
LOG==>[0/1]-  -- [j] has an ID opCode
LOG==>[0/1]---> now Search for matches of j in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-    j is matched by dummy var in j
YAC_LOG==>value: identifier rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[j] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!j
YAC_LOG==>expr_list: expr rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[j] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[j]
YAC_LOG==>ID sparecap [j]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[sparecap]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[sparecap] val2:[j] val3:[]
YAC_LOG==>identifier: iditem rule matched  sparecap[j]
LOG==>[0/1]-Finding ref:sparecap[j] in AmplModel(context):MCNFArcs
LOG==>[0/1]-  -- [sparecap[j]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of sparecap in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]---> continue searching in this_context[MCNFArcs]
LOG==>[0/1]-Found Match: sparecap refers to 
LOG==>[0/1]-             variable
LOG==>[0/1]-             sparecap
LOG==>[0/1]-             {ARCS}
LOG==>[0/1]-             >= 0
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28b50f0]
LOG==>[0/1]-Adding argument list to node: j
YAC_LOG==>value: identifier rule matched! sparecap[j]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[sparecap[j]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!sparecap[j]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[45] val1:[sum {k in COMM}Flow[k,j] + capslack[j]] val2:[sparecap[j]] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[45]
YAC_LOG==>iditem : ID rule matched , j
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
YAC_LOG==>identifier: iditem rule matched  j
LOG==>[0/1]-Finding ref:j in AmplModel(context):MCNFArcs
LOG==>[0/1]-  -- [j] has an ID opCode
LOG==>[0/1]---> now Search for matches of j in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-    j is matched by dummy var in j
YAC_LOG==>value: identifier rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[j] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!j
YAC_LOG==>expr_list: expr rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[j] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[j]
YAC_LOG==>ID basecap [j]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[basecap]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[basecap] val2:[j] val3:[]
YAC_LOG==>identifier: iditem rule matched  basecap[j]
LOG==>[0/1]-Finding ref:basecap[j] in AmplModel(context):MCNFArcs
LOG==>[0/1]-  -- [basecap[j]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of basecap in current active indexings
LOG==>[0/1]-Found dummy variable: a
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]---> continue searching in this_context[MCNFArcs]
LOG==>[0/1]-Found Match: basecap refers to 
LOG==>[0/1]-             parameter
LOG==>[0/1]-             basecap
LOG==>[0/1]-             {ARCS}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28ac060]
LOG==>[0/1]-Adding argument list to node: j
YAC_LOG==>value: identifier rule matched! basecap[j]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[basecap[j]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!basecap[j]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[383] val1:[sum {k in COMM}Flow[k,j] + capslack[j] - sparecap[j]] val2:[basecap[j]] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[383]
YAC_LOG==>subject to rule part2
YAC_LOG==>non-stoch model subject to - 
LOG==>[0/1]-Creating model component : id=Capacity indexing={j in ARCSDIFF} attribute=sum {k in COMM}Flow[k,j] + capslack[j] - sparecap[j] = basecap[j] type1
LOG==>[0/1]--- In setUpDependencies -- id=Capacity
LOG==>[0/1]- dependencies in indexing: {j in ARCSDIFF}
LOG==>[0/1]-  ARCSDIFF
LOG==>[0/1]- dependencies in attributes: sum {k in COMM}Flow[k,j] + capslack[j] - sparecap[j] = basecap[j]
LOG==>[0/1]-  COMM
LOG==>[0/1]-  Flow
LOG==>[0/1]-  capslack
LOG==>[0/1]-  sparecap
LOG==>[0/1]-  basecap
LOG==>[0/1]--- end setUpDependencies --dependencies.size=6
LOG==>[0/1]--- In addComp  -- this model:[MCNFArcs] level[1] add type[1]
LOG==>[0/1]--- In setUpDependencies -- id=Capacity
LOG==>[0/1]- dependencies in indexing: {j in ARCSDIFF}
LOG==>[0/1]-  ARCSDIFF
LOG==>[0/1]- dependencies in attributes: sum {k in COMM}Flow[k,j] + capslack[j] - sparecap[j] = basecap[j]
LOG==>[0/1]-  COMM
LOG==>[0/1]-  Flow
LOG==>[0/1]-  capslack
LOG==>[0/1]-  sparecap
LOG==>[0/1]-  basecap
LOG==>[0/1]--- end setUpDependencies --dependencies.size=6
LOG==>[0/1]--- End AddComp [current:MCNFArcs]  n_total[4]
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>rem indexing expression to list: {j in ARCSDIFF}
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>[rem_indexing] length[0]
YAC_LOG==>iditem : ID rule matched , NODES
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[NODES]
YAC_LOG==>identifier: iditem rule matched  NODES
LOG==>[0/1]-Finding ref:NODES in AmplModel(context):root
LOG==>[0/1]-  -- [NODES] has an ID opCode
LOG==>[0/1]---> now Search for matches of NODES in current active indexings
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: NODES refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             NODES
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a19e0]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[n]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[n] val2:[NODES] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[n in NODES] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{n in NODES}] LBR{(IN((ID T), IDREF(0x28c13a0:NODES(0x28a19e0))()))
YAC_LOG==>[add_index] - length of indexing now: 1
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>[rem_indexing] length[0]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[n in NODES] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{n in NODES}] LBR{(IN((ID T), IDREF(0x28c13a0:NODES(0x28a19e0))()))
YAC_LOG==>[add_index] - length of indexing now: 1
LOG==>[0/1]-AmplModel -- create - name[MCNFNodes] 
LOG==>[0/1]-Start Model: MCNFNodes {n in NODES}
LOG==>[0/1]-Creating model component : id=MCNFNodes indexing={n in NODES} attribute= type6
LOG==>[0/1]--- In setUpDependencies -- id=MCNFNodes
LOG==>[0/1]- dependencies in indexing: {n in NODES}
LOG==>[0/1]-  NODES
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[root] level[0] add type[6]
LOG==>[0/1]--- In setUpDependencies -- id=MCNFNodes
LOG==>[0/1]- dependencies in indexing: {n in NODES}
LOG==>[0/1]-  NODES
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:root]  n_total[14]
YAC_LOG==>setdef:[SET ID indexing_opt] - ID=[NODESDIFF] indexing_opt=[]
YAC_LOG==>iditem : ID rule matched , NODES
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[NODES]
YAC_LOG==>identifier: iditem rule matched  NODES
LOG==>[0/1]-Finding ref:NODES in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [NODES] has an ID opCode
LOG==>[0/1]---> now Search for matches of NODES in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]---> continue searching in this_context[MCNFNodes]
LOG==>[0/1]-Found Match: NODES refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             NODES
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a19e0]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>iditem : ID rule matched , n
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[n]
YAC_LOG==>identifier: iditem rule matched  n
LOG==>[0/1]-Finding ref:n in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [n] has an ID opCode
LOG==>[0/1]---> now Search for matches of n in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-    n is matched by dummy var in n
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>setexpression: LBRACE setexpression RBRACE -- rule matched
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[n] val2:[] val3:[]
LOG==>[0/1]-SetNode constructor called --opCode[357]
LOG==>[0/1]-ListSet constructor called  --- opCode[357] list[n]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[353] val1:[NODES] val2:[{n}] val3:[]
LOG==>[0/1]-SetNode constructor called --opCode[353]
LOG==>[0/1]-CompositeSet constructor called  -- opCode[353]
YAC_LOG==>match setexpression define rule
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[366] val1:[NODES diff {n}] val2:[] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[366]
YAC_LOG==>stochattr_opt=[]
YAC_LOG==>setattributes_opt=[:= NODES diff {n}]
LOG==>[0/1]-Creating model component : id=NODESDIFF indexing= attribute=:= NODES diff {n} type3
LOG==>[0/1]--- In setUpDependencies -- id=NODESDIFF
LOG==>[0/1]- dependencies in attributes: := NODES diff {n}
LOG==>[0/1]-  NODES
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[MCNFNodes] level[1] add type[3]
LOG==>[0/1]--- In setUpDependencies -- id=NODESDIFF
LOG==>[0/1]- dependencies in attributes: := NODES diff {n}
LOG==>[0/1]-  NODES
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:MCNFNodes]  n_total[1]
YAC_LOG==>setdef:[SET ID indexing_opt] - ID=[ARCSDIFF] indexing_opt=[]
YAC_LOG==>iditem : ID rule matched , ARCS
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCS]
YAC_LOG==>identifier: iditem rule matched  ARCS
LOG==>[0/1]-Finding ref:ARCS in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [ARCS] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCS in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]---> continue searching in this_context[MCNFNodes]
LOG==>[0/1]-Found Match: ARCS refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCS
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1d80]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[m]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[m] val2:[ARCS] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[m in ARCS] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{m in ARCS}] LBR{(IN((ID T), IDREF(0x28c3610:ARCS(0x28a1d80))()))
YAC_LOG==>[add_index] - length of indexing now: 2
YAC_LOG==>iditem : ID rule matched , m
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[m]
YAC_LOG==>identifier: iditem rule matched  m
LOG==>[0/1]-Finding ref:m in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [m] has an ID opCode
LOG==>[0/1]---> now Search for matches of m in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: m
LOG==>[0/1]-    m is matched by dummy var in m
YAC_LOG==>value: identifier rule matched! m
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[m] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!m
YAC_LOG==>expr_list: expr rule matched! m
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[m] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[m]
YAC_LOG==>ID arc_source [m]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[arc_source]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[arc_source] val2:[m] val3:[]
YAC_LOG==>identifier: iditem rule matched  arc_source[m]
LOG==>[0/1]-Finding ref:arc_source[m] in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [arc_source[m]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of arc_source in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: m
LOG==>[0/1]---> continue searching in this_context[MCNFNodes]
LOG==>[0/1]-Found Match: arc_source refers to 
LOG==>[0/1]-             parameter
LOG==>[0/1]-             arc_source
LOG==>[0/1]-             {ARCS}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28ad1c0]
LOG==>[0/1]-Adding argument list to node: m
YAC_LOG==>value: identifier rule matched! arc_source[m]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[arc_source[m]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!arc_source[m]
YAC_LOG==>iditem : ID rule matched , n
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[n]
YAC_LOG==>identifier: iditem rule matched  n
LOG==>[0/1]-Finding ref:n in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [n] has an ID opCode
LOG==>[0/1]---> now Search for matches of n in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-    n is matched by dummy var in n
YAC_LOG==>value: identifier rule matched! n
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[n] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!n
YAC_LOG==>expr_list: expr rule matched! n
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[n] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[n]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[364] val1:[n] val2:[] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[333] val1:[(n)] val2:[] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[346] val1:[arc_source[m]] val2:[ord(n)] val3:[]
YAC_LOG==>expr: expr NE expr -- rule matched [arc_source[m]]  [ord(n)]
YAC_LOG==>iditem : ID rule matched , m
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[m]
YAC_LOG==>identifier: iditem rule matched  m
LOG==>[0/1]-Finding ref:m in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [m] has an ID opCode
LOG==>[0/1]---> now Search for matches of m in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: m
LOG==>[0/1]-    m is matched by dummy var in m
YAC_LOG==>value: identifier rule matched! m
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[m] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!m
YAC_LOG==>expr_list: expr rule matched! m
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[m] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[m]
YAC_LOG==>ID arc_target [m]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[arc_target]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[arc_target] val2:[m] val3:[]
YAC_LOG==>identifier: iditem rule matched  arc_target[m]
LOG==>[0/1]-Finding ref:arc_target[m] in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [arc_target[m]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of arc_target in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: m
LOG==>[0/1]---> continue searching in this_context[MCNFNodes]
LOG==>[0/1]-Found Match: arc_target refers to 
LOG==>[0/1]-             parameter
LOG==>[0/1]-             arc_target
LOG==>[0/1]-             {ARCS}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28ae320]
LOG==>[0/1]-Adding argument list to node: m
YAC_LOG==>value: identifier rule matched! arc_target[m]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[arc_target[m]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!arc_target[m]
YAC_LOG==>iditem : ID rule matched , n
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[n]
YAC_LOG==>identifier: iditem rule matched  n
LOG==>[0/1]-Finding ref:n in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [n] has an ID opCode
LOG==>[0/1]---> now Search for matches of n in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-    n is matched by dummy var in n
YAC_LOG==>value: identifier rule matched! n
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[n] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!n
YAC_LOG==>expr_list: expr rule matched! n
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[n] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[n]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[364] val1:[n] val2:[] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[333] val1:[(n)] val2:[] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[346] val1:[arc_target[m]] val2:[ord(n)] val3:[]
YAC_LOG==>expr: expr NE expr -- rule matched [arc_target[m]]  [ord(n)]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[368] val1:[arc_source[m] != ord(n)] val2:[arc_target[m] != ord(n)] val3:[]
YAC_LOG==>expr: expr LOGICAL_AND expr -- rule matched [arc_source[m] != ord(n)]  [arc_target[m] != ord(n)]
YAC_LOG==>lexpr: expr rule matched! arc_source[m] != ord(n) && arc_target[m] != ord(n)
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>[rem_indexing] length[1]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[363] val1:[m in ARCS] val2:[arc_source[m] != ord(n) && arc_target[m] != ord(n)] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[m in ARCS: arc_source[m] != ord(n) && arc_target[m] != ord(n)] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>creating indexing set
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[{m in ARCS: arc_source[m] != ord(n) && arc_target[m] != ord(n)}] val2:[] val3:[]
LOG==>[0/1]-SetNode constructor called --opCode[357]
LOG==>[0/1]-IndexingSet constructor called -- opCode[357]
YAC_LOG==>match setexpression define rule
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[366] val1:[{{m in ARCS: arc_source[m] != ord(n) && arc_target[m] != ord(n)}}] val2:[] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[366]
YAC_LOG==>stochattr_opt=[]
YAC_LOG==>setattributes_opt=[:= {{m in ARCS: arc_source[m] != ord(n) && arc_target[m] != ord(n)}}]
LOG==>[0/1]-Creating model component : id=ARCSDIFF indexing= attribute=:= {{m in ARCS: arc_source[m] != ord(n) && arc_target[m] != ord(n)}} type3
LOG==>[0/1]--- In setUpDependencies -- id=ARCSDIFF
LOG==>[0/1]- dependencies in attributes: := {{m in ARCS: arc_source[m] != ord(n) && arc_target[m] != ord(n)}}
LOG==>[0/1]-  ARCS
LOG==>[0/1]-  arc_source
LOG==>[0/1]-  arc_target
LOG==>[0/1]--- end setUpDependencies --dependencies.size=3
LOG==>[0/1]--- In addComp  -- this model:[MCNFNodes] level[1] add type[3]
LOG==>[0/1]--- In setUpDependencies -- id=ARCSDIFF
LOG==>[0/1]- dependencies in attributes: := {{m in ARCS: arc_source[m] != ord(n) && arc_target[m] != ord(n)}}
LOG==>[0/1]-  ARCS
LOG==>[0/1]-  arc_source
LOG==>[0/1]-  arc_target
LOG==>[0/1]--- end setUpDependencies --dependencies.size=3
LOG==>[0/1]--- End AddComp [current:MCNFNodes]  n_total[2]
YAC_LOG==>iditem : ID rule matched , COMM
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[COMM]
YAC_LOG==>identifier: iditem rule matched  COMM
LOG==>[0/1]-Finding ref:COMM in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [COMM] has an ID opCode
LOG==>[0/1]---> now Search for matches of COMM in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]---> continue searching in this_context[MCNFNodes]
LOG==>[0/1]-Found Match: COMM refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             COMM
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1b00]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[k]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[k] val2:[COMM] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[k in COMM] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{k in COMM}] LBR{(IN((ID T), IDREF(0x28c53e0:COMM(0x28a1b00))()))
YAC_LOG==>[add_index] - length of indexing now: 2
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>[rem_indexing] length[1]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[k in COMM] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{k in COMM}] LBR{(IN((ID T), IDREF(0x28c53e0:COMM(0x28a1b00))()))
YAC_LOG==>[add_index] - length of indexing now: 2
LOG==>[0/1]-AmplModel -- create - name[Net] 
LOG==>[0/1]-Start Model: Net {k in COMM}
LOG==>[0/1]-Creating model component : id=Net indexing={k in COMM} attribute= type6
LOG==>[0/1]--- In setUpDependencies -- id=Net
LOG==>[0/1]- dependencies in indexing: {k in COMM}
LOG==>[0/1]-  COMM
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[MCNFNodes] level[1] add type[6]
LOG==>[0/1]--- In setUpDependencies -- id=Net
LOG==>[0/1]- dependencies in indexing: {k in COMM}
LOG==>[0/1]-  COMM
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:MCNFNodes]  n_total[3]
YAC_LOG==>iditem : ID rule matched , ARCSDIFF
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCSDIFF]
YAC_LOG==>identifier: iditem rule matched  ARCSDIFF
LOG==>[0/1]-Finding ref:ARCSDIFF in AmplModel(context):Net
LOG==>[0/1]-  -- [ARCSDIFF] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCSDIFF in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: ARCSDIFF refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCSDIFF
LOG==>[0/1]-             := {{m in ARCS: arc_source[m] != ord(n) && arc_target[m] != ord(n)}}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28c45c0]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCSDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{ARCSDIFF}] LBR{(IDREF(0x28c5800:ARCSDIFF(0x28c45c0))())
YAC_LOG==>[add_index] - length of indexing now: 3
YAC_LOG==>[rem_indexing] length[3]
YAC_LOG==>[rem_indexing] length[2]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCSDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{ARCSDIFF}] LBR{(IDREF(0x28c5800:ARCSDIFF(0x28c45c0))())
YAC_LOG==>[add_index] - length of indexing now: 3
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[-99] val1:[] val2:[] val3:[]
LOG==>[0/1]-ValueNode constructor --- opCode [-99] value[0]
YAC_LOG==>expr: value rule matched!0
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[348] val1:[0] val2:[] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[348]
LOG==>[0/1]-In addItemToListOrCreate -- 
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[>= 0] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[>= 0]
LOG==>[0/1]-Creating model component : id=Flow indexing={ARCSDIFF} attribute=>= 0 type0
LOG==>[0/1]--- In setUpDependencies -- id=Flow
LOG==>[0/1]- dependencies in indexing: {ARCSDIFF}
LOG==>[0/1]-  ARCSDIFF
LOG==>[0/1]- dependencies in attributes: >= 0
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[Net] level[2] add type[0]
LOG==>[0/1]--- In setUpDependencies -- id=Flow
LOG==>[0/1]- dependencies in indexing: {ARCSDIFF}
LOG==>[0/1]-  ARCSDIFF
LOG==>[0/1]- dependencies in attributes: >= 0
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:Net]  n_total[1]
YAC_LOG==>[rem_indexing] length[3]
YAC_LOG==>rem indexing expression to list: {ARCSDIFF}
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>iditem : ID rule matched , NODESDIFF
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[NODESDIFF]
YAC_LOG==>identifier: iditem rule matched  NODESDIFF
LOG==>[0/1]-Finding ref:NODESDIFF in AmplModel(context):Net
LOG==>[0/1]-  -- [NODESDIFF] has an ID opCode
LOG==>[0/1]---> now Search for matches of NODESDIFF in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: NODESDIFF refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             NODESDIFF
LOG==>[0/1]-             := NODES diff {n}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28c2860]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[i]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[i] val2:[NODESDIFF] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[i in NODESDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{i in NODESDIFF}] LBR{(IN((ID T), IDREF(0x28c79c0:NODESDIFF(0x28c2860))()))
YAC_LOG==>[add_index] - length of indexing now: 3
YAC_LOG==>[rem_indexing] length[3]
YAC_LOG==>[rem_indexing] length[2]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[i in NODESDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>subject to rule matched - ID[FlowBlance]
YAC_LOG==>[add_index] - indexing:[{i in NODESDIFF}] LBR{(IN((ID T), IDREF(0x28c79c0:NODESDIFF(0x28c2860))()))
YAC_LOG==>[add_index] - length of indexing now: 3
YAC_LOG==>iditem : ID rule matched , ARCSDIFF
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCSDIFF]
YAC_LOG==>identifier: iditem rule matched  ARCSDIFF
LOG==>[0/1]-Finding ref:ARCSDIFF in AmplModel(context):Net
LOG==>[0/1]-  -- [ARCSDIFF] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCSDIFF in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: ARCSDIFF refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCSDIFF
LOG==>[0/1]-             := {{m in ARCS: arc_source[m] != ord(n) && arc_target[m] != ord(n)}}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28c45c0]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[j] val2:[ARCSDIFF] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[j in ARCSDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{j in ARCSDIFF}] LBR{(IN((ID T), IDREF(0x28c7e40:ARCSDIFF(0x28c45c0))()))
YAC_LOG==>[add_index] - length of indexing now: 4
YAC_LOG==>iditem : ID rule matched , j
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
YAC_LOG==>identifier: iditem rule matched  j
LOG==>[0/1]-Finding ref:j in AmplModel(context):Net
LOG==>[0/1]-  -- [j] has an ID opCode
LOG==>[0/1]---> now Search for matches of j in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-    j is matched by dummy var in j
YAC_LOG==>value: identifier rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[j] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!j
YAC_LOG==>expr_list: expr rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[j] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[j]
YAC_LOG==>ID arc_target [j]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[arc_target]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[arc_target] val2:[j] val3:[]
YAC_LOG==>identifier: iditem rule matched  arc_target[j]
LOG==>[0/1]-Finding ref:arc_target[j] in AmplModel(context):Net
LOG==>[0/1]-  -- [arc_target[j]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of arc_target in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: arc_target refers to 
LOG==>[0/1]-             parameter
LOG==>[0/1]-             arc_target
LOG==>[0/1]-             {ARCS}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28ae320]
LOG==>[0/1]-Adding argument list to node: j
YAC_LOG==>value: identifier rule matched! arc_target[j]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[arc_target[j]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!arc_target[j]
YAC_LOG==>iditem : ID rule matched , i
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[i]
YAC_LOG==>identifier: iditem rule matched  i
LOG==>[0/1]-Finding ref:i in AmplModel(context):Net
LOG==>[0/1]-  -- [i] has an ID opCode
LOG==>[0/1]---> now Search for matches of i in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-    i is matched by dummy var in i
YAC_LOG==>value: identifier rule matched! i
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[i] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!i
YAC_LOG==>expr_list: expr rule matched! i
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[i] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[i]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[364] val1:[i] val2:[] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[333] val1:[(i)] val2:[] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[349] val1:[arc_target[j]] val2:[ord(i)] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[349]
YAC_LOG==>[rem_indexing] length[4]
YAC_LOG==>[rem_indexing] length[3]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[363] val1:[j in ARCSDIFF] val2:[arc_target[j] == ord(i)] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[j in ARCSDIFF: arc_target[j] == ord(i)] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{j in ARCSDIFF: arc_target[j] == ord(i)}] LBR{(COLON(IN((ID T), IDREF(0x28c7e40:ARCSDIFF(0x28c45c0))()), "349"("0"(IDREF(0x28c8110:arc_target(0x28ae320))("0"((ID T)))), "333"(LBR((COMMA("0"((ID T))))))))
YAC_LOG==>[add_index] - length of indexing now: 4
YAC_LOG==>iditem : ID rule matched , j
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
YAC_LOG==>identifier: iditem rule matched  j
LOG==>[0/1]-Finding ref:j in AmplModel(context):Net
LOG==>[0/1]-  -- [j] has an ID opCode
LOG==>[0/1]---> now Search for matches of j in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-    j is matched by dummy var in j
YAC_LOG==>value: identifier rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[j] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!j
YAC_LOG==>expr_list: expr rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[j] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[j]
YAC_LOG==>ID Flow [j]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[Flow]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[Flow] val2:[j] val3:[]
YAC_LOG==>identifier: iditem rule matched  Flow[j]
LOG==>[0/1]-Finding ref:Flow[j] in AmplModel(context):Net
LOG==>[0/1]-  -- [Flow[j]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of Flow in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: Flow refers to 
LOG==>[0/1]-             variable
LOG==>[0/1]-             Flow
LOG==>[0/1]-             {ARCSDIFF}
LOG==>[0/1]-             >= 0
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28c6b80]
LOG==>[0/1]-Adding argument list to node: j
YAC_LOG==>value: identifier rule matched! Flow[j]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[Flow[j]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!Flow[j]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[342] val1:[{j in ARCSDIFF: arc_target[j] == ord(i)}] val2:[Flow[j]] val3:[]
YAC_LOG==>[rem_indexing] length[4]
YAC_LOG==>rem indexing expression to list: {j in ARCSDIFF: arc_target[j] == ord(i)}
YAC_LOG==>[rem_indexing] length[3]
YAC_LOG==>iditem : ID rule matched , ARCSDIFF
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCSDIFF]
YAC_LOG==>identifier: iditem rule matched  ARCSDIFF
LOG==>[0/1]-Finding ref:ARCSDIFF in AmplModel(context):Net
LOG==>[0/1]-  -- [ARCSDIFF] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCSDIFF in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: ARCSDIFF refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCSDIFF
LOG==>[0/1]-             := {{m in ARCS: arc_source[m] != ord(n) && arc_target[m] != ord(n)}}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28c45c0]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[j] val2:[ARCSDIFF] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[j in ARCSDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{j in ARCSDIFF}] LBR{(IN((ID T), IDREF(0x28c8b10:ARCSDIFF(0x28c45c0))()))
YAC_LOG==>[add_index] - length of indexing now: 4
YAC_LOG==>iditem : ID rule matched , j
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
YAC_LOG==>identifier: iditem rule matched  j
LOG==>[0/1]-Finding ref:j in AmplModel(context):Net
LOG==>[0/1]-  -- [j] has an ID opCode
LOG==>[0/1]---> now Search for matches of j in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-    j is matched by dummy var in j
YAC_LOG==>value: identifier rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[j] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!j
YAC_LOG==>expr_list: expr rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[j] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[j]
YAC_LOG==>ID arc_source [j]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[arc_source]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[arc_source] val2:[j] val3:[]
YAC_LOG==>identifier: iditem rule matched  arc_source[j]
LOG==>[0/1]-Finding ref:arc_source[j] in AmplModel(context):Net
LOG==>[0/1]-  -- [arc_source[j]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of arc_source in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: arc_source refers to 
LOG==>[0/1]-             parameter
LOG==>[0/1]-             arc_source
LOG==>[0/1]-             {ARCS}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28ad1c0]
LOG==>[0/1]-Adding argument list to node: j
YAC_LOG==>value: identifier rule matched! arc_source[j]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[arc_source[j]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!arc_source[j]
YAC_LOG==>iditem : ID rule matched , i
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[i]
YAC_LOG==>identifier: iditem rule matched  i
LOG==>[0/1]-Finding ref:i in AmplModel(context):Net
LOG==>[0/1]-  -- [i] has an ID opCode
LOG==>[0/1]---> now Search for matches of i in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-    i is matched by dummy var in i
YAC_LOG==>value: identifier rule matched! i
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[i] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!i
YAC_LOG==>expr_list: expr rule matched! i
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[i] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[i]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[364] val1:[i] val2:[] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[333] val1:[(i)] val2:[] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[349] val1:[arc_source[j]] val2:[ord(i)] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[349]
YAC_LOG==>[rem_indexing] length[4]
YAC_LOG==>[rem_indexing] length[3]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[363] val1:[j in ARCSDIFF] val2:[arc_source[j] == ord(i)] val3:[]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[j in ARCSDIFF: arc_source[j] == ord(i)] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{j in ARCSDIFF: arc_source[j] == ord(i)}] LBR{(COLON(IN((ID T), IDREF(0x28c8b10:ARCSDIFF(0x28c45c0))()), "349"("0"(IDREF(0x28c8dc0:arc_source(0x28ad1c0))("0"((ID T)))), "333"(LBR((COMMA("0"((ID T))))))))
YAC_LOG==>[add_index] - length of indexing now: 4
YAC_LOG==>iditem : ID rule matched , j
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
YAC_LOG==>identifier: iditem rule matched  j
LOG==>[0/1]-Finding ref:j in AmplModel(context):Net
LOG==>[0/1]-  -- [j] has an ID opCode
LOG==>[0/1]---> now Search for matches of j in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-    j is matched by dummy var in j
YAC_LOG==>value: identifier rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[j] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!j
YAC_LOG==>expr_list: expr rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[j] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[j]
YAC_LOG==>ID Flow [j]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[Flow]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[Flow] val2:[j] val3:[]
YAC_LOG==>identifier: iditem rule matched  Flow[j]
LOG==>[0/1]-Finding ref:Flow[j] in AmplModel(context):Net
LOG==>[0/1]-  -- [Flow[j]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of Flow in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: Flow refers to 
LOG==>[0/1]-             variable
LOG==>[0/1]-             Flow
LOG==>[0/1]-             {ARCSDIFF}
LOG==>[0/1]-             >= 0
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28c6b80]
LOG==>[0/1]-Adding argument list to node: j
YAC_LOG==>value: identifier rule matched! Flow[j]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[Flow[j]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!Flow[j]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[342] val1:[{j in ARCSDIFF: arc_source[j] == ord(i)}] val2:[Flow[j]] val3:[]
YAC_LOG==>[rem_indexing] length[4]
YAC_LOG==>rem indexing expression to list: {j in ARCSDIFF: arc_source[j] == ord(i)}
YAC_LOG==>[rem_indexing] length[3]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[45] val1:[sum {j in ARCSDIFF: arc_target[j] == ord(i)}Flow[j]] val2:[sum {j in ARCSDIFF: arc_source[j] == ord(i)}Flow[j]] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[45]
YAC_LOG==>iditem : ID rule matched , k
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[k]
YAC_LOG==>identifier: iditem rule matched  k
LOG==>[0/1]-Finding ref:k in AmplModel(context):Net
LOG==>[0/1]-  -- [k] has an ID opCode
LOG==>[0/1]---> now Search for matches of k in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-    k is matched by dummy var in k
YAC_LOG==>value: identifier rule matched! k
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[k] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!k
YAC_LOG==>expr_list: expr rule matched! k
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[k] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[k]
YAC_LOG==>iditem : ID rule matched , i
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[i]
YAC_LOG==>identifier: iditem rule matched  i
LOG==>[0/1]-Finding ref:i in AmplModel(context):Net
LOG==>[0/1]-  -- [i] has an ID opCode
LOG==>[0/1]---> now Search for matches of i in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]-    i is matched by dummy var in i
YAC_LOG==>value: identifier rule matched! i
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[i] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!i
YAC_LOG==>ID b [k,i]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[b]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[b] val2:[k,i] val3:[]
YAC_LOG==>identifier: iditem rule matched  b[k,i]
LOG==>[0/1]-Finding ref:b[k,i] in AmplModel(context):Net
LOG==>[0/1]-  -- [b[k,i]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of b in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-Found dummy variable: i
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: b refers to 
LOG==>[0/1]-             parameter
LOG==>[0/1]-             b
LOG==>[0/1]-             {k in COMM,i in NODES}
LOG==>[0/1]-             := if (comm_source[k] == ord(i)) then comm_demand[k] else if (comm_target[k] == ord(i)) then - comm_demand[k] else 0
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28b3db0]
LOG==>[0/1]-Adding argument list to node: k,i
YAC_LOG==>value: identifier rule matched! b[k,i]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[b[k,i]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!b[k,i]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[383] val1:[sum {j in ARCSDIFF: arc_target[j] == ord(i)}Flow[j] - sum {j in ARCSDIFF: arc_source[j] == ord(i)}Flow[j]] val2:[b[k,i]] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[383]
YAC_LOG==>subject to rule part2
YAC_LOG==>non-stoch model subject to - 
LOG==>[0/1]-Creating model component : id=FlowBlance indexing={i in NODESDIFF} attribute=sum {j in ARCSDIFF: arc_target[j] == ord(i)}Flow[j] - sum {j in ARCSDIFF: arc_source[j] == ord(i)}Flow[j] = b[k,i] type1
LOG==>[0/1]--- In setUpDependencies -- id=FlowBlance
LOG==>[0/1]- dependencies in indexing: {i in NODESDIFF}
LOG==>[0/1]-  NODESDIFF
LOG==>[0/1]- dependencies in attributes: sum {j in ARCSDIFF: arc_target[j] == ord(i)}Flow[j] - sum {j in ARCSDIFF: arc_source[j] == ord(i)}Flow[j] = b[k,i]
LOG==>[0/1]-  ARCSDIFF
LOG==>[0/1]-  arc_target
LOG==>[0/1]-  Flow
LOG==>[0/1]-  arc_source
LOG==>[0/1]-  b
LOG==>[0/1]--- end setUpDependencies --dependencies.size=6
LOG==>[0/1]--- In addComp  -- this model:[Net] level[2] add type[1]
LOG==>[0/1]--- In setUpDependencies -- id=FlowBlance
LOG==>[0/1]- dependencies in indexing: {i in NODESDIFF}
LOG==>[0/1]-  NODESDIFF
LOG==>[0/1]- dependencies in attributes: sum {j in ARCSDIFF: arc_target[j] == ord(i)}Flow[j] - sum {j in ARCSDIFF: arc_source[j] == ord(i)}Flow[j] = b[k,i]
LOG==>[0/1]-  ARCSDIFF
LOG==>[0/1]-  arc_target
LOG==>[0/1]-  Flow
LOG==>[0/1]-  arc_source
LOG==>[0/1]-  b
LOG==>[0/1]--- end setUpDependencies --dependencies.size=6
LOG==>[0/1]--- End AddComp [current:Net]  n_total[2]
YAC_LOG==>[rem_indexing] length[3]
YAC_LOG==>rem indexing expression to list: {i in NODESDIFF}
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>iditem : ID rule matched , ARCSDIFF
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCSDIFF]
YAC_LOG==>identifier: iditem rule matched  ARCSDIFF
LOG==>[0/1]-Finding ref:ARCSDIFF in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [ARCSDIFF] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCSDIFF in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]---> continue searching in this_context[MCNFNodes]
LOG==>[0/1]-Found Match: ARCSDIFF refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCSDIFF
LOG==>[0/1]-             := {{m in ARCS: arc_source[m] != ord(n) && arc_target[m] != ord(n)}}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28c45c0]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCSDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{ARCSDIFF}] LBR{(IDREF(0x28cab60:ARCSDIFF(0x28c45c0))())
YAC_LOG==>[add_index] - length of indexing now: 2
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>[rem_indexing] length[1]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[ARCSDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>[add_index] - indexing:[{ARCSDIFF}] LBR{(IDREF(0x28cab60:ARCSDIFF(0x28c45c0))())
YAC_LOG==>[add_index] - length of indexing now: 2
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[-99] val1:[] val2:[] val3:[]
LOG==>[0/1]-ValueNode constructor --- opCode [-99] value[0]
YAC_LOG==>expr: value rule matched!0
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[348] val1:[0] val2:[] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[348]
LOG==>[0/1]-In addItemToListOrCreate -- 
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[>= 0] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[>= 0]
LOG==>[0/1]-Creating model component : id=capslacknode indexing={ARCSDIFF} attribute=>= 0 type0
LOG==>[0/1]--- In setUpDependencies -- id=capslacknode
LOG==>[0/1]- dependencies in indexing: {ARCSDIFF}
LOG==>[0/1]-  ARCSDIFF
LOG==>[0/1]- dependencies in attributes: >= 0
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- In addComp  -- this model:[MCNFNodes] level[1] add type[0]
LOG==>[0/1]--- In setUpDependencies -- id=capslacknode
LOG==>[0/1]- dependencies in indexing: {ARCSDIFF}
LOG==>[0/1]-  ARCSDIFF
LOG==>[0/1]- dependencies in attributes: >= 0
LOG==>[0/1]--- end setUpDependencies --dependencies.size=1
LOG==>[0/1]--- End AddComp [current:MCNFNodes]  n_total[4]
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>rem indexing expression to list: {ARCSDIFF}
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>iditem : ID rule matched , ARCSDIFF
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCSDIFF]
YAC_LOG==>identifier: iditem rule matched  ARCSDIFF
LOG==>[0/1]-Finding ref:ARCSDIFF in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [ARCSDIFF] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCSDIFF in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]---> continue searching in this_context[MCNFNodes]
LOG==>[0/1]-Found Match: ARCSDIFF refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCSDIFF
LOG==>[0/1]-             := {{m in ARCS: arc_source[m] != ord(n) && arc_target[m] != ord(n)}}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28c45c0]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[j] val2:[ARCSDIFF] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[j in ARCSDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{j in ARCSDIFF}] LBR{(IN((ID T), IDREF(0x28cbd70:ARCSDIFF(0x28c45c0))()))
YAC_LOG==>[add_index] - length of indexing now: 2
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>[rem_indexing] length[1]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[j in ARCSDIFF] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>indexing_opt : indexing rule matched!
YAC_LOG==>subject to rule matched - ID[Capacity]
YAC_LOG==>[add_index] - indexing:[{j in ARCSDIFF}] LBR{(IN((ID T), IDREF(0x28cbd70:ARCSDIFF(0x28c45c0))()))
YAC_LOG==>[add_index] - length of indexing now: 2
YAC_LOG==>iditem : ID rule matched , COMM
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[COMM]
YAC_LOG==>identifier: iditem rule matched  COMM
LOG==>[0/1]-Finding ref:COMM in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [COMM] has an ID opCode
LOG==>[0/1]---> now Search for matches of COMM in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]---> continue searching in this_context[MCNFNodes]
LOG==>[0/1]-Found Match: COMM refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             COMM
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1b00]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[k]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[k] val2:[COMM] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[k in COMM] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{k in COMM}] LBR{(IN((ID T), IDREF(0x28cc1e0:COMM(0x28a1b00))()))
YAC_LOG==>[add_index] - length of indexing now: 3
YAC_LOG==>[rem_indexing] length[3]
YAC_LOG==>[rem_indexing] length[2]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[k in COMM] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{k in COMM}] LBR{(IN((ID T), IDREF(0x28cc1e0:COMM(0x28a1b00))()))
YAC_LOG==>[add_index] - length of indexing now: 3
YAC_LOG==>iditem : ID rule matched , k
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[k]
YAC_LOG==>identifier: iditem rule matched  k
LOG==>[0/1]-Finding ref:k in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [k] has an ID opCode
LOG==>[0/1]---> now Search for matches of k in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]-    k is matched by dummy var in k
YAC_LOG==>value: identifier rule matched! k
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[k] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!k
YAC_LOG==>expr_list: expr rule matched! k
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[k] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[k]
YAC_LOG==>ID Net [k]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[Net]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[Net] val2:[k] val3:[]
YAC_LOG==>identifier: iditem rule matched  Net[k]
LOG==>[0/1]-Finding ref:Net[k] in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [Net[k]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of Net in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]---> continue searching in this_context[MCNFNodes]
LOG==>[0/1]-Found Match: Net refers to 
LOG==>[0/1]-             submodel
LOG==>[0/1]-             Net
LOG==>[0/1]-             {k in COMM}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[374] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[374] ModelComp[0x28c56d0]
LOG==>[0/1]-Adding argument list to node: k
YAC_LOG==>iditem : ID rule matched , j
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
YAC_LOG==>identifier: iditem rule matched  j
LOG==>[0/1]-Finding ref:j in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [j] has an ID opCode
LOG==>[0/1]---> now Search for matches of j in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-    j is matched by dummy var in j
YAC_LOG==>value: identifier rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[j] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!j
YAC_LOG==>expr_list: expr rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[j] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[j]
YAC_LOG==>ID Flow [j]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[Flow]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[Flow] val2:[j] val3:[]
LOG==>[0/1]-Finding ref:Flow[j] in AmplModel(context):Net
LOG==>[0/1]-  -- [Flow[j]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of Flow in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-Found dummy variable: k
LOG==>[0/1]---> continue searching in this_context[Net]
LOG==>[0/1]-Found Match: Flow refers to 
LOG==>[0/1]-             variable
LOG==>[0/1]-             Flow
LOG==>[0/1]-             {ARCSDIFF}
LOG==>[0/1]-             >= 0
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28c6b80]
LOG==>[0/1]-Adding argument list to node: j
YAC_LOG==>Merge identifier:Net-----> iditem:Flow[]
YAC_LOG==>value: identifier rule matched! Flow[k,j]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[Flow[k,j]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!Flow[k,j]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[342] val1:[{k in COMM}] val2:[Flow[k,j]] val3:[]
YAC_LOG==>[rem_indexing] length[3]
YAC_LOG==>rem indexing expression to list: {k in COMM}
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>iditem : ID rule matched , j
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
YAC_LOG==>identifier: iditem rule matched  j
LOG==>[0/1]-Finding ref:j in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [j] has an ID opCode
LOG==>[0/1]---> now Search for matches of j in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-    j is matched by dummy var in j
YAC_LOG==>value: identifier rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[j] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!j
YAC_LOG==>expr_list: expr rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[j] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[j]
YAC_LOG==>ID capslacknode [j]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[capslacknode]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[capslacknode] val2:[j] val3:[]
YAC_LOG==>identifier: iditem rule matched  capslacknode[j]
LOG==>[0/1]-Finding ref:capslacknode[j] in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [capslacknode[j]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of capslacknode in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]---> continue searching in this_context[MCNFNodes]
LOG==>[0/1]-Found Match: capslacknode refers to 
LOG==>[0/1]-             variable
LOG==>[0/1]-             capslacknode
LOG==>[0/1]-             {ARCSDIFF}
LOG==>[0/1]-             >= 0
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28caf00]
LOG==>[0/1]-Adding argument list to node: j
YAC_LOG==>value: identifier rule matched! capslacknode[j]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[capslacknode[j]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!capslacknode[j]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[43] val1:[sum {k in COMM}Flow[k,j]] val2:[capslacknode[j]] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[43]
YAC_LOG==>iditem : ID rule matched , j
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
YAC_LOG==>identifier: iditem rule matched  j
LOG==>[0/1]-Finding ref:j in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [j] has an ID opCode
LOG==>[0/1]---> now Search for matches of j in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-    j is matched by dummy var in j
YAC_LOG==>value: identifier rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[j] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!j
YAC_LOG==>expr_list: expr rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[j] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[j]
YAC_LOG==>ID sparecap [j]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[sparecap]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[sparecap] val2:[j] val3:[]
YAC_LOG==>identifier: iditem rule matched  sparecap[j]
LOG==>[0/1]-Finding ref:sparecap[j] in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [sparecap[j]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of sparecap in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]---> continue searching in this_context[MCNFNodes]
LOG==>[0/1]-Found Match: sparecap refers to 
LOG==>[0/1]-             variable
LOG==>[0/1]-             sparecap
LOG==>[0/1]-             {ARCS}
LOG==>[0/1]-             >= 0
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28b50f0]
LOG==>[0/1]-Adding argument list to node: j
YAC_LOG==>value: identifier rule matched! sparecap[j]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[sparecap[j]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!sparecap[j]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[45] val1:[sum {k in COMM}Flow[k,j] + capslacknode[j]] val2:[sparecap[j]] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[45]
YAC_LOG==>iditem : ID rule matched , j
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[j]
YAC_LOG==>identifier: iditem rule matched  j
LOG==>[0/1]-Finding ref:j in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [j] has an ID opCode
LOG==>[0/1]---> now Search for matches of j in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]-    j is matched by dummy var in j
YAC_LOG==>value: identifier rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[j] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!j
YAC_LOG==>expr_list: expr rule matched! j
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[j] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[j]
YAC_LOG==>ID basecap [j]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[basecap]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[basecap] val2:[j] val3:[]
YAC_LOG==>identifier: iditem rule matched  basecap[j]
LOG==>[0/1]-Finding ref:basecap[j] in AmplModel(context):MCNFNodes
LOG==>[0/1]-  -- [basecap[j]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of basecap in current active indexings
LOG==>[0/1]-Found dummy variable: n
LOG==>[0/1]-Found dummy variable: j
LOG==>[0/1]---> continue searching in this_context[MCNFNodes]
LOG==>[0/1]-Found Match: basecap refers to 
LOG==>[0/1]-             parameter
LOG==>[0/1]-             basecap
LOG==>[0/1]-             {ARCS}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28ac060]
LOG==>[0/1]-Adding argument list to node: j
YAC_LOG==>value: identifier rule matched! basecap[j]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[basecap[j]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!basecap[j]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[383] val1:[sum {k in COMM}Flow[k,j] + capslacknode[j] - sparecap[j]] val2:[basecap[j]] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[383]
YAC_LOG==>subject to rule part2
YAC_LOG==>non-stoch model subject to - 
LOG==>[0/1]-Creating model component : id=Capacity indexing={j in ARCSDIFF} attribute=sum {k in COMM}Flow[k,j] + capslacknode[j] - sparecap[j] = basecap[j] type1
LOG==>[0/1]--- In setUpDependencies -- id=Capacity
LOG==>[0/1]- dependencies in indexing: {j in ARCSDIFF}
LOG==>[0/1]-  ARCSDIFF
LOG==>[0/1]- dependencies in attributes: sum {k in COMM}Flow[k,j] + capslacknode[j] - sparecap[j] = basecap[j]
LOG==>[0/1]-  COMM
LOG==>[0/1]-  Flow
LOG==>[0/1]-  capslacknode
LOG==>[0/1]-  sparecap
LOG==>[0/1]-  basecap
LOG==>[0/1]--- end setUpDependencies --dependencies.size=6
LOG==>[0/1]--- In addComp  -- this model:[MCNFNodes] level[1] add type[1]
LOG==>[0/1]--- In setUpDependencies -- id=Capacity
LOG==>[0/1]- dependencies in indexing: {j in ARCSDIFF}
LOG==>[0/1]-  ARCSDIFF
LOG==>[0/1]- dependencies in attributes: sum {k in COMM}Flow[k,j] + capslacknode[j] - sparecap[j] = basecap[j]
LOG==>[0/1]-  COMM
LOG==>[0/1]-  Flow
LOG==>[0/1]-  capslacknode
LOG==>[0/1]-  sparecap
LOG==>[0/1]-  basecap
LOG==>[0/1]--- end setUpDependencies --dependencies.size=6
LOG==>[0/1]--- End AddComp [current:MCNFNodes]  n_total[5]
YAC_LOG==>[rem_indexing] length[2]
YAC_LOG==>rem indexing expression to list: {j in ARCSDIFF}
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>[rem_indexing] length[0]
YAC_LOG==>iditem : ID rule matched , ARCS
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[ARCS]
YAC_LOG==>identifier: iditem rule matched  ARCS
LOG==>[0/1]-Finding ref:ARCS in AmplModel(context):root
LOG==>[0/1]-  -- [ARCS] has an ID opCode
LOG==>[0/1]---> now Search for matches of ARCS in current active indexings
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: ARCS refers to 
LOG==>[0/1]-             set
LOG==>[0/1]-             ARCS
LOG==>[0/1]-             ordered
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28a1d80]
YAC_LOG==>setexpression: identifier -- rule matched
YAC_LOG==>ID IN setexpression rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[x]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[344] val1:[x] val2:[ARCS] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[344]
YAC_LOG==>start_indexing : LBRACE setexpr_list rule matched!
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[x in ARCS] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{x in ARCS}] LBR{(IN((ID T), IDREF(0x28ce490:ARCS(0x28a1d80))()))
YAC_LOG==>[add_index] - length of indexing now: 1
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>[rem_indexing] length[0]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[357] val1:[x in ARCS] val2:[] val3:[]
LOG==>[0/1]-Creating syntaxNode opCode[357]
LOG==>[0/1]-Created SyntaxNodeIx .... 
YAC_LOG==>[add_index] - indexing:[{x in ARCS}] LBR{(IN((ID T), IDREF(0x28ce490:ARCS(0x28a1d80))()))
YAC_LOG==>[add_index] - length of indexing now: 1
YAC_LOG==>iditem : ID rule matched , x
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[x]
YAC_LOG==>identifier: iditem rule matched  x
LOG==>[0/1]-Finding ref:x in AmplModel(context):root
LOG==>[0/1]-  -- [x] has an ID opCode
LOG==>[0/1]---> now Search for matches of x in current active indexings
LOG==>[0/1]-Found dummy variable: x
LOG==>[0/1]-    x is matched by dummy var in x
YAC_LOG==>value: identifier rule matched! x
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[x] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!x
YAC_LOG==>expr_list: expr rule matched! x
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[x] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[x]
YAC_LOG==>ID sparecap [x]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[sparecap]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[sparecap] val2:[x] val3:[]
YAC_LOG==>identifier: iditem rule matched  sparecap[x]
LOG==>[0/1]-Finding ref:sparecap[x] in AmplModel(context):root
LOG==>[0/1]-  -- [sparecap[x]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of sparecap in current active indexings
LOG==>[0/1]-Found dummy variable: x
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: sparecap refers to 
LOG==>[0/1]-             variable
LOG==>[0/1]-             sparecap
LOG==>[0/1]-             {ARCS}
LOG==>[0/1]-             >= 0
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28b50f0]
LOG==>[0/1]-Adding argument list to node: x
YAC_LOG==>value: identifier rule matched! sparecap[x]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[sparecap[x]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!sparecap[x]
YAC_LOG==>iditem : ID rule matched , x
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[x]
YAC_LOG==>identifier: iditem rule matched  x
LOG==>[0/1]-Finding ref:x in AmplModel(context):root
LOG==>[0/1]-  -- [x] has an ID opCode
LOG==>[0/1]---> now Search for matches of x in current active indexings
LOG==>[0/1]-Found dummy variable: x
LOG==>[0/1]-    x is matched by dummy var in x
YAC_LOG==>value: identifier rule matched! x
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[x] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!x
YAC_LOG==>expr_list: expr rule matched! x
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[359] val1:[x] val2:[] val3:[]
LOG==>[0/1]-ListNode  constructor called -- with opCode[359] val1[x]
YAC_LOG==>ID cost [x]
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[258] val1:[] val2:[] val3:[]
LOG==>[0/1]-IDNode constructor called  - opCode[258] ID[cost]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[361] val1:[cost] val2:[x] val3:[]
YAC_LOG==>identifier: iditem rule matched  cost[x]
LOG==>[0/1]-Finding ref:cost[x] in AmplModel(context):root
LOG==>[0/1]-  -- [cost[x]] has an LSBRACKET or LBRACKET opCode
LOG==>[0/1]---> now Search for matches of cost in current active indexings
LOG==>[0/1]-Found dummy variable: x
LOG==>[0/1]---> continue searching in this_context[root]
LOG==>[0/1]-Found Match: cost refers to 
LOG==>[0/1]-             parameter
LOG==>[0/1]-             cost
LOG==>[0/1]-             {ARCS}
LOG==>[0/1]-SyntaxNode constructor  --- 0<- opCode[373] val1:[] val2:[] val3:[]
LOG==>[0/1]-SyntaxNodeIDREF constructor called -- opCode[373] ModelComp[0x28aaf00]
LOG==>[0/1]-Adding argument list to node: x
YAC_LOG==>value: identifier rule matched! cost[x]
LOG==>[0/1]-SyntaxNode constructor  --- 1<- opCode[0] val1:[cost[x]] val2:[] val3:[]
YAC_LOG==>expr: value rule matched!cost[x]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[42] val1:[sparecap[x]] val2:[cost[x]] val3:[]
LOG==>[0/1]-OpNode constructor called -- opCode[42]
LOG==>[0/1]-SyntaxNode constructor  --- 2<- opCode[342] val1:[{x in ARCS}] val2:[sparecap[x] * cost[x]] val3:[]
YAC_LOG==>[rem_indexing] length[1]
YAC_LOG==>rem indexing expression to list: {x in ARCS}
YAC_LOG==>[rem_indexing] length[0]
LOG==>[0/1]-Creating model component : id=costToInstall indexing= attribute=sum {x in ARCS}sparecap[x] * cost[x] type4
LOG==>[0/1]--- In setUpDependencies -- id=costToInstall
LOG==>[0/1]- dependencies in attributes: sum {x in ARCS}sparecap[x] * cost[x]
LOG==>[0/1]-  ARCS
LOG==>[0/1]-  sparecap
LOG==>[0/1]-  cost
LOG==>[0/1]--- end setUpDependencies --dependencies.size=3
LOG==>[0/1]--- In addComp  -- this model:[root] level[0] add type[4]
LOG==>[0/1]--- In setUpDependencies -- id=costToInstall
LOG==>[0/1]- dependencies in attributes: sum {x in ARCS}sparecap[x] * cost[x]
LOG==>[0/1]-  ARCS
LOG==>[0/1]-  sparecap
LOG==>[0/1]-  cost
LOG==>[0/1]--- end setUpDependencies --dependencies.size=3
LOG==>[0/1]--- End AddComp [current:root]  n_total[15]
YAC_LOG==>model parse is done!
LOG==>[0/1]-============== analyse_constraints =============================
LOG==>[0/1]-ModelComp::analyseConstraint --id[costToInstall] attr[sum {x in ARCS}sparecap[x] * cost[x]] declared level[0]
LOG==>[0/1]-id[sparecap] model[root] level[0]
LOG==>[0/1]-Variable Declare Level: 0
LOG==>[0/1]-	   Depend Level: 0
LOG==>[0/1]-ModelComp::analyseConstraint --id[Capacity] attr[sum {k in COMM}Flow[k,j] + capslack[j] - sparecap[j] = basecap[j]] declared level[1]
LOG==>[0/1]-id[Flow] model[Net] level[2]
LOG==>[0/1]-id[capslack] model[MCNFArcs] level[1]
LOG==>[0/1]-id[sparecap] model[root] level[0]
LOG==>[0/1]-Variable Declare Level: 0
LOG==>[0/1]-	   Depend Level: 0
LOG==>[0/1]-Variable Declare Level: 1
LOG==>[0/1]-	   Depend Level: 1
LOG==>[0/1]-Variable Declare Level: 2
LOG==>[0/1]-	   Depend Level: 2
LOG==>[0/1]-ModelComp::analyseConstraint --id[FlowBalance] attr[sum {j in ARCSDIFF: arc_target[j] == ord(i)}Flow[j] - sum {x in ARCSDIFF: arc_source[x] == ord(i)}Flow[x] = b[k,i]] declared level[2]
LOG==>[0/1]-id[Flow] model[Net] level[2]
LOG==>[0/1]-id[Flow] model[Net] level[2]
LOG==>[0/1]-Variable Declare Level: 2
LOG==>[0/1]-	   Depend Level: 2
LOG==>[0/1]-ModelComp::analyseConstraint --id[Capacity] attr[sum {k in COMM}Flow[k,j] + capslacknode[j] - sparecap[j] = basecap[j]] declared level[1]
LOG==>[0/1]-id[Flow] model[Net] level[2]
LOG==>[0/1]-id[capslacknode] model[MCNFNodes] level[1]
LOG==>[0/1]-id[sparecap] model[root] level[0]
LOG==>[0/1]-Variable Declare Level: 0
LOG==>[0/1]-	   Depend Level: 0
LOG==>[0/1]-Variable Declare Level: 1
LOG==>[0/1]-	   Depend Level: 1
LOG==>[0/1]-Variable Declare Level: 2
LOG==>[0/1]-	   Depend Level: 2
??:0
/home/s0965328/workspace/psmg/psmg-oops/Debug/../src/model/AmplModel.cpp:124
/home/s0965328/workspace/psmg/psmg-oops/Debug/../src/model/AmplModel.cpp:128
/home/s0965328/workspace/psmg/psmg-oops/Debug/../src/sml/Sml.cpp:126
/home/s0965328/workspace/psmg/psmg-oops/Debug/../src/wrapper.cpp:186
??:0
??:0
Executable name initialised: /home/s0965328/workspace/psmg/psmg-oops/Debug/psmg-oops
[bt] #1 /lib/x86_64-linux-gnu/libc.so.6(+0x364a0) [0x7f45072884a0]
[bt] #2 ./psmg-oops() [0x42adae]
[bt] #3 ./psmg-oops() [0x42ae58]
[bt] #4 ./psmg-oops() [0x419199]
[bt] #5 ./psmg-oops() [0x481fe3]
[bt] #6 /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xed) [0x7f450727376d]
[bt] #7 ./psmg-oops() [0x40b9b9]
leaving...
