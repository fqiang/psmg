/* (c) 2008,2009 Jonathan Hogg and Andreas Grothey, University of Edinburgh
 *
 * This file is part of SML.
 *
 * SML is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, using version 3 of the License.
 *
 * SML is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 */

%debug
%{
 	#include "../util/global_util_functions.h"
   	#include "../context/Set.h"
	#include "../context/ModelContext.h"
	#include "../context/PValueSym.h"
	#include "../context/PValueValue.h"
   	#include "../context/ParamMult.h"
   	#include "../context/ParamSingle.h"
   	#include "../model/AmplModel.h"
   	#include "../model/ModelComp.h"
   	#include <cassert>
   	#include <cstdlib>
   	#include <iostream>
   	#include <sstream>
   	#include <errno.h>

   	#define YYERROR_VERBOSE

   	using namespace std;

   	int datalex(void);
   	static void dataerror(const char *s);
   	extern FILE *datain;
   	extern int datalineno;
   	ModelContext* rootContext;
 
%}

%union
{
   long ival;
   double fval;
   char* string;
}

%type <string> set_name 
%type <string> set_value
%type <string> member_pairs member_pair
%type <string> member_items 
%type <string> member


%type <string> param_name  param_names
%type <string> param_specs param_specs_item


%token <string> ID 
%token <string> INT
%token <string> FLOAT 

%token DATA
%token SET PARAM TR
%token DEFINE
%token PLUS MINUS DOT SEMICOLON COLON 
%token LBRACE RBRACE LSBRACKET RSBRACKET LBRACKET RBRACKET
%token COMMA


%nonassoc SEMICOLON

%%

statements: /* empty */
          	| statements statement 
          	;

statement:  set_def
			| param_def
			| DATA SEMICOLON {
				YAC_DATA_LOG("data rule matched");
			}
         	;

set_def:	SET set_name DEFINE member SEMICOLON {
				YAC_DATA_LOG("set define start - FOR === ["<<$2<<"]");
				YAC_DATA_LOG("   ===== VALUE ====");
				YAC_DATA_LOG($4);
				
				string id($2);
				SetComp* setComp = AmplModel::root->findSetComp(id);
				Set* setValue = Set::createSet(setComp);
				char* token;
				token = strtok($4,",() ");
			
				ostringstream oss(ostringstream::out);
				unsigned int tokenNum = 0;
				do
				{
					oss<<token;
					tokenNum++;
					if(tokenNum%setValue->dim == 0)
					{
						setValue->addSetValue(oss.str());
						oss.str("");
						oss.clear();
					}
					token = strtok(NULL,",() ");
				}while(token!=NULL);
	
				
				setComp->setCard = setValue->card;
				rootContext->addCompValueMap(setComp,setValue);
        	}
			;            

set_name:	ID { 
				$$ = $1;
			}
			;

member:		  member_items {
				//YAC_DATA_LOG("member_items["<<$1<<"]"); 
				$$ = $1; 
			}
			| member_pairs { 
				//YAC_DATA_LOG("member_pairs["<<$1<<"]");
				$$ = $1;
			}
			;

member_items: set_value {
				//YAC_DATA_LOG("last set value ["<<$1<<"]");
				$$ = $1;
			}
			| member_items set_value {
				ostringstream oss(ostringstream::out);
				oss<<$1<<','<<$2;
				free($1);
				free($2);
				$$ = strdup(oss.str().c_str());
			}
			;

member_pairs: LBRACKET member_pair RBRACKET {
				//YAC_DATA_LOG("last set value tuple ["<<$2<<"]");
				ostringstream oss(ostringstream::out);
				oss<<'('<<$2<<')';
				free($2);
				$$ = strdup(oss.str().c_str());
			}
			| member_pairs LBRACKET member_pair RBRACKET {
				//YAC_DATA_LOG("a set value tuple ["<<$3<<"]");
				ostringstream oss(ostringstream::out);
				oss<<$1<<'('<<$3<<')';
				free($1);
				free($3);
				$$ = strdup(oss.str().c_str());
			}
			;
			
member_pair: set_value  { 
				$$ = $1;
			}
			| member_pair COMMA set_value {
				ostringstream oss(ostringstream::out);
				oss<<$1<<','<<$3;
				free($1);
				free($3);
				$$ = strdup(oss.str().c_str());
			}
			;

param_def:	PARAM param_name DEFINE param_specs SEMICOLON { 
				YAC_DATA_LOG("single param define start -FOR === ["<<$2<<"]");
				YAC_DATA_LOG("   ===== VALUE ====");
				YAC_DATA_LOG($4);
				string id($2);
				ParamComp* paramComp = AmplModel::root->findParamComp(id);
				Param* param = NULL;
				
				param = new ParamSingle(paramComp);
				assert(paramComp->numIndicies == 0);
				PValue* pval = NULL;
				if(paramComp->isSym){
					string v($4);
					pval = new PValueSym(v);
				}
				else
				{
					pval = new PValueValue(atof($4));
	            }
	            static_cast<ParamSingle*>(param)->setParamValue(pval);
	            assert(param->card == 1);
                rootContext->addCompValueMap(paramComp,param);
			}
			| PARAM COLON set_name COLON param_names DEFINE param_specs SEMICOLON
			{
				YAC_DATA_LOG("multiple params and set define start");
				YAC_DATA_LOG("set : "<<$3<<"  params: "<<$5);
				YAC_DATA_LOG("   ===== VALUE ====");
				YAC_DATA_LOG($7);
				
				string setid($3);
				SetComp* setComp = AmplModel::root->findSetComp(setid);
				assert(setComp->setDim == 1); //only 1-dim set can be specified in this grammar
				Set* setValue = Set::createSet(setComp);
				rootContext->addCompValueMap(setComp,setValue);
				
				char* tok = strtok($5,",");
				vector<ParamComp*> paramModels;
				vector<Param*> params;
				int numIndicies = 0;
				while(tok!=NULL)
				{
					string id(tok);
					ParamComp* paramComp = AmplModel::root->findParamComp(id);
					Param* param = new ParamMult(paramComp);
					paramModels.push_back(paramComp);
					params.push_back(param);
					rootContext->addCompValueMap(paramComp,param);		
					assert(numIndicies = paramComp->numIndicies || numIndicies == 0);
					tok = strtok(NULL,",");
				}
				
				ostringstream oss(ostringstream::out);
                int curr_index = 0;
				tok = strtok($7,",");
				while(tok!=NULL)
				{
					YAC_DATA_LOG("tok: - "<<tok);
					oss<<tok;
                    ++curr_index;
					if(curr_index == numIndicies)
                    {
                    		setValue->addSetValue(oss.str());
                    		vector<Param*>::iterator i=params.begin();
                    		vector<ParamComp*>::iterator j=paramModels.begin();
                    		for(;i!=params.end();i++,j++)
                            {
                                    tok=strtok(NULL,",");
                                    ParamMult* p = static_cast<ParamMult*>(*i);
                                    ParamComp* pc = (*j);
                            		
                            		PValue* pval = NULL;
                            		if(pc->isSym){
                            			string v(tok);
                            			pval = new PValueSym(v);
                            		}
                            		else {
                            			pval = new PValueValue(atof(tok));
                            		}
                            		p->addParamValue(oss.str(),pval);
                            }
                            oss.str("");
                            curr_index = 0;
                    }
                    tok = strtok(NULL,",");
				}
			}
			| PARAM COLON param_names DEFINE param_specs SEMICOLON {
				YAC_DATA_LOG("multiple params define start -FOR === ["<<$3<<"]");
				YAC_DATA_LOG("   ===== VALUE ====");
				YAC_DATA_LOG($5);
				
				char* tok = strtok($3,",");
				vector<ParamComp*> paramModels;
				vector<Param*> params;
				int numIndicies = 0;
				int numIndicies_init = -1;
				while(tok!=NULL)
				{
					string id(tok);
					ParamComp* paramComp = AmplModel::root->findParamComp(id);
					paramModels.push_back(paramComp);
					Param* paramValue = new ParamMult(paramComp);
					params.push_back(paramValue);
					rootContext->addCompValueMap(paramComp,paramValue);
					
					numIndicies = paramComp->numIndicies;
					if(numIndicies_init == -1) numIndicies_init = numIndicies;
					assert(numIndicies_init==numIndicies);
					
					tok = strtok(NULL,",");
				}
				
				ostringstream oss(ostringstream::out);
                int curr_index = 0;
				tok = strtok($5,",");
				while(tok!=NULL)
				{
					oss<<tok;
                    ++curr_index;
					if(curr_index == numIndicies)
                    {
                    		vector<Param*>::iterator i=params.begin();
                        	vector<ParamComp*>::iterator j=paramModels.begin();
                            for(;i!=params.end();i++,j++)
                            {
                                    tok=strtok(NULL,",");
                                    YAC_DATA_LOG(tok);
                                 	ParamMult* p = static_cast<ParamMult*>(*i);
                                    ParamComp* pc = (*j);
                                    
                                    PValue* pval = NULL;
                                    if(pc->isSym)
                                    {
                                    	string v(tok);
                                    	pval = new PValueSym(v);
                                    }
                                    else
                                    {
                                    	double v = atof(tok);
                                    	pval = new PValueValue(v);
                                    }
                                    p->addParamValue(oss.str(),pval);
                            }
                            oss.str("");
                            curr_index = 0;
                    }
                    tok = strtok(NULL,",");
				}
			}
			;

param_names: param_name {
				$$ = $1;
			}
			|	param_names param_name {
				ostringstream oss(ostringstream::out);
				oss<<$1<<','<<$2;  //each param_name(set_value) is on newline
				free($1);
				free($2);
				$$ = strdup(oss.str().c_str());
			}
			;

param_specs: param_specs_item{
				$$ = $1;
			}
			| param_specs param_specs_item {
				ostringstream oss(ostringstream::out);
				oss<<$1<<','<<$2;  //each on newline
				free($1);
				free($2);
				$$ = strdup(oss.str().c_str());
			}
			;
			
param_specs_item: ID {
				$$ = $1;
			}
			| INT {
				$$ = $1;
			}
			| FLOAT {
				$$ = $1;
			}
			;

param_name:	ID {
				$$ = $1;
			}
			;	

set_value: ID { 
				$$ = $1;
			}
			| INT {
				$$ = $1;
			}
			;

%%

void dataerror(const char *s) {
  cerr << "INPUT:[" << s << "] on line " << datalineno << "\n";
  exit(1);
}

void parse_data(ModelContext* context) {
       
	YAC_DATA_LOG("===============================================================");
	YAC_DATA_LOG(" Start parsing data file: " << Config::datafilename);
	YAC_DATA_LOG("===============================================================");
	rootContext = context;
  	datain = fopen(Config::datafilename.c_str(), "r");
  	if (datain==NULL){
    	printf("ERROR: Data file '%s' error:%s \n",Config::datafilename.c_str(),strerror(errno));
    	exit(1);
  	}
          
  	dataparse();
  	YAC_DATA_LOG("===============================================================");
  	YAC_DATA_LOG(" Finished parsing data file");
  	YAC_DATA_LOG("===============================================================");
	fclose(datain);
}

static void print_token_value (FILE *file, int type, YYSTYPE value)
{
	fprintf (file, "%s", value.string);
}


//main(int argc,char** argv )
//{
// 	++argv, --argc;  /* skip over program name */
// 	if ( argc > 0 )
// 	{
//	   	datain = fopen( argv[0], "r" );
//  }
// 	else
// 	{
//     	datain = stdin;
//  }
//	
//	while(dataparse());
//}

